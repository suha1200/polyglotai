{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Un des premiers ordinateurs, \"Colossus\", a été construit en 1944 par l'équipe de", "section_path": ["Un des premiers ordinateurs, \"Colossus\", a été construit en 1944 par l'équipe de"], "page": 1, "content": "Introduction\nà la Cyber Sécurité - 2021\nMachine Enigma, Imperial War Museum, Londres\nPascal Urien - Télécom Paris"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network", "section_path": ["Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network"], "page": 2, "content": "2\nUne tentative de définition de la Cybersécurité. ................................................... 6\nIntroduction ........................................................................................................... 7\nOrdinateurs et sécurité des applications ............................................................ 7\nLe Réseau Téléphonique Commuté (RTC) ....................................................... 9\nL'internet ......................................................................................................... 10\nL'internet sans fil, les réseaux radio ................................................................ 11\nTransfert de fichiers et streaming .................................................................... 11\nRoaming, VPN ................................................................................................ 11\nDu Data Center au Cloud ................................................................................ 12\nL’Architecture Logicielle Réseau selon REST ................................................... 12\nSécurité du Cloud ................................................................................................ 13\nModèle du Cloud - NIST Special Publication 800-145 .................................. 13\nSurface d'attaque du Cloud ............................................................................. 15\nEléments de sécurité du Cloud ........................................................................ 15\nNetwork Isolation and Segmentation .......................................................... 15\nApplication Isolation ................................................................................... 15\nData Security ............................................................................................... 16\nIdentity and Access Management (IAM). ................................................... 16\nL'émergence du monde connecté et l'internet des objets (IoT) ........................... 17\nTOP 10 des attaques IoT, OWASP 2018 ........................................................ 18\nProtocoles de l'Internet of Things (IoT) .......................................................... 19\nCoAP (Constrained Application Protocol) .................................................. 19\nLWM2M (Lightweight Machine to Machine Technical Specification) ..... 20\nMQTT (MQ Telemetry Transport) ............................................................ 20\nQuelques plateformes logicielles pour l'IoT .................................................. 20\nThread ......................................................................................................... 22\nOpen Connectivity Foundation OCF .......................................................... 23\nHAP ............................................................................................................ 24\nHue Smart Lighting ..................................................................................... 25\nBrillo et Weave ........................................................................................... 25\nIntégrité des systèmes embarqués ....................................................................... 26\nFLASH Disk ................................................................................................... 27\nDongle Bluetooth ............................................................................................ 28\nDongle Wi-Fi .................................................................................................. 28\nAVR ................................................................................................................ 29\nSécurité des Systèmes Industriels ....................................................................... 30\nSCADA ........................................................................................................... 30\nSTUXNET, une arme logicielle .................................................................. 31\nCar Hacking. ................................................................................................... 32\nAttaques récentes sur les voitures connectées ............................................. 34\nSurface d’attaque du véhicule connecté autonome ............................................. 36\nExemple d’architecture de communication d’une TESLA ............................. 37\nTypes d’attaques ............................................................................................. 38\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network", "section_path": ["Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network"], "page": 3, "content": "3\nMéthodes de défense ....................................................................................... 38\nDeep Learning & Attaques ................................................................................. 39\nIntroduction aux techniques Deep Learning (DL) .......................................... 39\nAttaques des systèmes Deep Learning ............................................................ 41\nL’émergence des Crypto-Monnaies, Blockchain, Smart Contracts .................... 43\nBitcoin ............................................................................................................. 43\nEthereum et smart contract ............................................................................. 45\nExemple de contrats: les jetons ERC20 ...................................................... 47\nSécurité des Applications Distribuées, Emergence de la Cyber Sécurité ............ 48\nSécurité des applications ............................................................................. 48\nSécurité des protocoles de communication et des réseaux .......................... 48\nSécurité du système d'exploitation .............................................................. 49\nSécurité Hardware ....................................................................................... 49\nQuelques paradigmes de sécurité ........................................................................ 50\nClassification des types d’attaques ................................................................. 50\nHeuristiques de défense: placebo, vaccin, défense immunitaire ..................... 50\nFacteurs de Vulnérabilité: Complexité, Extensibilité, Connectivité ............... 51\nUne Méthodologie de Cyber Attaque: Empreinte, Collecte, Inventaire.......... 51\nSystèmes Embarqués ...................................................................................... 52\nPrincipes de sécurité. .......................................................................................... 52\nIdentification ................................................................................................... 52\nAuthentification .............................................................................................. 52\nConfidentialité ................................................................................................ 53\nIntégrité ........................................................................................................... 53\nNon-répudiation .............................................................................................. 53\nDisponibilité .................................................................................................... 53\nAu sujet de la confiance .................................................................................. 53\nSécurité des Réseaux ........................................................................................... 54\nSécurité au niveau physique ............................................................................ 55\nSécurité au niveau MAC ................................................................................. 55\nSécurité au niveau réseau/transport ................................................................. 55\nCouche de Sécurité entre transport et application ........................................... 56\nSécurité au niveau application ........................................................................ 56\nEléments de Sécurité ........................................................................................... 57\nAuthentification - Autorisation ....................................................................... 57\nSécurité du canal ............................................................................................. 58\nSécurité des échanges de Diffie Hellman ........................................................ 59\nComment trouver des générateurs dans Z/pZ* ........................................... 60\nSafe Prime ................................................................................................... 60\nAttaque DH et contre mesure ...................................................................... 60\nMise à jour des clés cryptographiques ........................................................ 61\nIdentité et Organisations ................................................................................. 62\nTaxonomie des méthodes d’authentification................................................... 63\nMécanismes symétriques: mot de passe, pre-shared key, provisionning .... 63\nMécanismes Asymétriques ......................................................................... 65\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network", "section_path": ["Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network"], "page": 4, "content": "4\nLes tunnels .................................................................................................. 65\nLes faiblesses du protocole IP ............................................................................. 66\nLes solutions sécurisées IP classiques: VPN, TLS, Kerberos, SSH .................... 67\nIPSEC ............................................................................................................. 67\nTLS/SSL ......................................................................................................... 69\nTLS1.3 ............................................................................................................ 71\nAu sujet du Phishing ....................................................................................... 73\nKerberos .......................................................................................................... 73\nPPTP-EAP ...................................................................................................... 74\nSSH ................................................................................................................. 75\nLimitation des protections offertes par les pare-feu. ........................................... 76\nAu sujet des normes Critères Communs (CC) .................................................... 77\nHeuristiques d'Attaque ........................................................................................ 79\nL’intrusion. ..................................................................................................... 79\nProgrammes Malveillants, Virus, Vers ........................................................... 79\nExemple le ver Blaster (2003)..................................................................... 81\nAu sujet des botnets ........................................................................................ 81\nAu sujet des rootkits........................................................................................ 82\nLe buffer overflow .......................................................................................... 82\nLe Fuzzing ...................................................................................................... 84\nL'injection SQL ............................................................................................... 84\nLe Cross Site Scripting CSS ........................................................................... 84\nCross Site Request Forgery CSRF .................................................................. 84\nAutour de la Sécurité des Systèmes d'Exploitation ............................................. 84\nStratégie de défense du système Windows (2005) .......................................... 84\nPrincipes de sécurité du système Android....................................................... 85\nIntégrité du code, obfuscation, TPM ............................................................... 86\nCas d'usage: la sécurité des consoles de jeu XBOX (2002) ............................ 87\nExemple de classification des attaques pour les systèmes embarqués. ........... 88\nSecure Elements .............................................................................................. 89\nTrusted Execution Environment ..................................................................... 91\nHardware Secure Module (HSM) ................................................................... 92\nIntel SGX ........................................................................................................ 93\nObfuscation ..................................................................................................... 95\nIndistinguishability Obfuscation ..................................................................... 97\nWhite-Box Cryptography (WBC) ................................................................... 97\nIntégrité physique et logicielle ............................................................................ 99\nIntégrité physique............................................................................................ 99\nLes implants matériels ................................................................................ 99\nLes relais ................................................................................................... 100\nAnti clonage de processeur : techniques SRAM PUF ............................... 102\nAttestation distante (remote attestation) ........................................................ 104\nIntégrité logicielle pour un système embarqué ............................................. 105\nRemote Attestation .................................................................................... 106\nBijective MAC, BMAC ............................................................................ 106\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network", "section_path": ["Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network"], "page": 5, "content": "5\nLes Canaux Cachés. .......................................................................................... 108\nSingle Power Analysis .................................................................................. 108\nDifferential Power Analysis .......................................................................... 108\nFaites moi confiance ? 20 ans de bugs et heuristiques ...................................... 110\nSpectre et Meltdown: insécurité des processeurs .............................................. 121\nAttaques récentes sur le Wi-Fi .......................................................................... 123\nAttaques sur les fonctions de hash MD5 et SHA-1 ........................................... 126\nQuelques TOP10 d'attaques .............................................................................. 127\nLe TOP9 des menaces visant le cloud computing en 2013 ........................... 127\nOWASP TOP10 2013 ................................................................................... 129\nAttaques TLS diverses ...................................................................................... 131\nL’attaque par renégociation (2009) ............................................................... 131\nL’attaque BEAST (2011) .............................................................................. 131\nL’attaque Lucky Thirteen (2013) .................................................................. 132\nAttaque TLS Triple Handshake (2014) ......................................................... 134\nHeartBleed (2014) ......................................................................................... 135\nL’attaque RC4 du L’attaque Royal Holloway (2013) ................................... 135\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Une tentative de définition de la Cybersécurité.", "section_path": ["Une tentative de définition de la Cybersécurité."], "page": 6, "content": "6\nIntroduction à la\nCyber Sécurité\nUne tentative de définition de la Cybersécurité.\nLa cybersécurité vise à garantir le fonctionnement \"normal\" (nonimal)\nd’un système numérique.\nBien que ce fonctionnement normal (\"goodware\") soit difficile à définir\nformellement, l’idée est que le système reste conforme à un cahier des\ncharges. Le but d’un attaquant est de modifier le comportement (\"behavior\")\ndu système numérique et/ou d’accéder à des informations confidentielles.\nUn système numérique est composé de processeurs, associés à des\nmémoires hébergeant des programmes et des données. Des canaux d’entrées\nsorties (I/O) permettent des interactions locales (clavier, écran…) ou\ndistantes (réseaux…) avec des humains ou des machines.\nLes applications numériques sont multiples, véhicules autonomes,\nsupervision de processus industriels, commerce électronique, échange\nd’information multimédia, réseau domotique…\nLa surface d’attaque, et donc le périmètre de défense de la cybersécurité,\nest complexe à appréhender, les technologies (microélectronique,\nalgorithmes, protocoles…) ayant évoluées sous la pression du marché, en\nl’absence de pré-requis de sécurité.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L'hyperviseur Xen a été créé à la fin des années 90, par Keir Fraser et Ian Pratt,", "section_path": ["L'hyperviseur Xen a été créé à la fin des années 90, par Keir Fraser et Ian Pratt,"], "page": 7, "content": "7\nIntroduction\nUne application distribuée est réalisée par un ensemble d’entités\nlogicielles logiquement autonomes, qui produisent, consomment et\néchangent des informations ( OUTi = PROG(INi) ).\nIN2\nIN1 PROG1 PROG2\nGLUEWARE\nOUT1\nOUT2\nOrdinateurs et sécurité des applications\nDans un premier temps1 les composants logiciels des applications étaient\nlogés dans un même système informatique, constituant de fait leur média de\ncommunication (parfois dénommé gluware). Le bus système permet le\ntransfert des informations stockées en mémoire, les modules logiciels sont\nréalisés par des processus gérés par le système d’exploitation. La sécurité est\nuniquement dépendante des caractéristiques du système d’exploitation, par\nexemple en termes de gestion des droits utilisateurs, ou d’isolement des\nprocessus.\nLe transistor a été inventé fin 1947 par John Bardeen, William Shockley et\nWalter Brattain (prix Nobel de physique en 1956). L'entreprise INTEL fondée\nen 1968 par les docteurs Gordon Moore, Robert Noyce et Andrew Grove,\ncréa en 1971 le premier microprocesseur 4 bits (le 4004, comportant 2300\ntransistors). Un microprocesseur CISC (complex instruction set computer) est\norganisé autour d’une unité arithmétique et logique (ALU) qui exécute des\nmicro-instructions (µI) stockées dans la mémoire du microprogramme (µP).\nDans ce cas l’intégrité du µP est le point zéro de la confiance. Dans le modèle\nRISC (reduced instruction set computing) il n’y a pas de µP, les instructions\nsont exécutées par un décodeur d’instruction.\nLe PDP-11 (Programmable Data Processor) commercialisé par Digital\nEquipment Corporation (DEC) dans la période 1970 et 1993 a popularisé\nl'architecture classique des ordinateurs comprenant, un CPU, un bus\nsystème, des mémoires, et des dispositifs d'entrée/sortie (I/O).\n1 Un des premiers ordinateurs, \"Colossus\", a été construit en 1944 par l'équipe de\nTommy Flowers selon les spécifications de Max Newman. Il comportait dans sa\ndernière version, 2400 tubes à vide.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "\"The Internet of Things. How the Next Evolution of the Internet Is Changing", "section_path": ["\"The Internet of Things. How the Next Evolution of the Internet Is Changing"], "page": 8, "content": "8\nLe système PDP 11, 1970\nIllustration des attaques et défenses dans un système informatique\nclassique. Le système d’exploitation réalise l’isolation logique des\nprogrammes. Le contenu des mémoires non chiffré, transite en clair sur le\nbus système.\nLe système d'exploitation CP/M (ancêtre du DOS), créé en 1974 par Gary\nKildall, fondateur de Digital Research utilisait des lignes de commande selon\nla syntaxe ProgramName FileIn FileOut.\nArchitecture de Harward (à gauche) et Von Newmann (à droite)\nRemarquons qu'il existe deux classes majeures d'architecture\nd'ordinateur: l'architecture de Harvard (systèmes embarqués…) pour\nlaquelle les mémoires de données (RAM) et de code (FLASH) sont disjointes,\net l'architecture de Von Neumann (Unix, Windows…) où le code et les\ndonnées sont stockées une mémoire (RAM) commune. L’injection de code\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Le Réseau Téléphonique Commuté (RTC)", "section_path": ["Le Réseau Téléphonique Commuté (RTC)"], "page": 9, "content": "9\nest plus difficile dans le cas d’une architecture de Harvard, puisqu’il est\nnécessaire de stocker le code malveillant dans la mémoire (FLASH) des\ninstructions. Par exemple une attaque \"buffer overflow\" injecte des\ninstructions dans la mémoire RAM, l’exécution de code en RAM est\nimpossible dans le modèle de Harvard.\nLe Réseau Téléphonique Commuté (RTC)\nDans une deuxième période l’application distribuée est\nrépartie entre plusieurs systèmes informatiques reliés entre\neux par des liens de communications supposés surs (c’est à\ndire qu’il est difficile d’enregistrer ou de modifier\nl’information transmise), tels que modems ou liaisons\nspécialisées (X25, RNIS …). Remarquons à ce propos qu’il\nest possible de sécuriser une liaison de type point à point par un dispositif\nmatériel de chiffrement. Sous UNIX des applications telles que RLOGIN\npermettent de se connecter à une machine distante à l'aide d'un identifiant et\nd'un mot de passe, qui sont échangés sans protection particulère.\nIN2\nIN1 PROG1 PROG2\nRéseau\nTéléphonique\nOUT1\nCommuté\nOUT2\n3274:Unité de contrôle\nFEP: Front End\nProcessor\nMainframe & Front End Processor (FEP): 1960-1980\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "IBM, Building Smarter Planet Solutions with MQTT and IBM WebSphere", "section_path": ["IBM, Building Smarter Planet Solutions with MQTT and IBM WebSphere"], "page": 10, "content": "10\nL'internet\nEnfin l’émergence de l'internet2, puis de la toile d’araignée\nmondiale (WEB3) a permis de concevoir des systèmes\ndistribués à l’échelle planétaire. Les composants logiciels\nsont répartis sur des systèmes informatiques hétérogènes,\nle réseau n’est pas sûr, le nombre d’utilisateurs est\nimportant.\nD'abord absente des premiers standards, la sécurité de\nl'Internet (Security Architecture for the Internet Protocol, RFC 825, 1995), puis\ndu WEB (Secure Socket Layer, SSL 3.0, 1996) devient un paramètre critique et\ntente de concilier des contraintes à priori antinomiques telles que, nécessité\néconomique d’utiliser Internet, et impérative résistance au piratage\ninformatique ou à l’espionnage.\nPoster de Tim Berners-Lee à la conférence ACM Hypertext 91.\nIN2\nIN1 PROG1 PROG2\nInternet\nOUT1\nOUT2\n2 Vinton G. Cerf and Roberty E. Kahn \"A Protocol for Packet Network\nIntercommunication\", IEEE Trans on Comms, Vol Com-22, No 5 May 1974.\n3 Tim Berners-Lee. \"The World Wide Web\", Poster, ACM Hypertext 91\nConference.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Roaming, VPN", "section_path": ["Roaming, VPN"], "page": 11, "content": "11\nL'internet sans fil, les réseaux radio\nLa dernière révolution des communications repose sur les technologies\nde réseaux IP sans fil, tels que Wi-Fi4, WiMAX5 ou réseaux cellulaires\n3G/4G/5G. Les liens filaires symboles d’une connectivité volontaire et\ncontrôlée s’estompent; l’infrastructure du réseau devient diffuse et invisible.\nUn nouveau besoin de sécurité6 s’affirme, le contrôle des accès réseaux et la\nconfidentialité des données.\nIN2\nIN1 PROG1 PROG2\nInternet\nOUT1\nOUT2\nTransfert de fichiers et streaming\nLes réseaux de communication transportent les données produites et\nconsommées par les systèmes distribués. Ils offrent deux types de services\nfondamentaux, le transfert de fichiers (un ensemble de données prédéfinies) et\nla diffusion d’informations, en temps réel, en mode flux (streaming). La\npremière catégorie comporte des services tels que le courrier électronique\n(POP, SMTP…), le WEB (HTTP) et diverses méthodes d’échange\nd’information (FTP, NNTP, …). La deuxième catégorie regroupe les\nprotocoles relatifs au multimédia ou à la téléphonie sur IP, par exemple RTP,\nH323, ou SIP.\nRoaming, VPN\nLes fournisseurs de services internet gèrent un ensemble de serveurs qui\nstockent les données et les applications de leurs clients (base de données,\nmessageries, fichiers…). Le roaming consiste à autoriser l’accès à distance de\nces ressources, ce qui implique également la gestion sécurisée de la mobilité\ndes utilisateurs, typiquement à l’aide de protocoles VPN (Virtual Private\nNetwork). Chez les particuliers une box (modem ADSL) établit un lien point à\npoint avec le réseau de l'Internet Service Provider (ISP).\n4 IEEE 802.11b, Septembre 1999\n5 IEEE 802.16e, Décembre 2005\n6 IEEE 802.11i, 2004\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L’Architecture Logicielle Réseau selon REST", "section_path": ["L’Architecture Logicielle Réseau selon REST"], "page": 12, "content": "12\nDu Data Center au Cloud\nDurant la période 2000-2010 les grands fournisseurs de\nservices de l’Internet (tels que Google, Facebook,…) ont\ndéveloppé une technologie s’appuyant sur des Data Centers,\nc'est-à-dire des sites informatiques regroupant jusqu’à un\nmillion d’ordinateurs (cartes mère), pour un\ncoût de l’ordre de 600 M$, et consommant\nenviron 100 MW (le dixième d’un réacteur nucléaire). Cette\napproche est à la base du concept du Cloud Computing, le\nclient est équipé d’un terminal léger comportant un\nnavigateur ou une machine virtuelle, la sécurité d’accès au\nservice repose sur des technologies WEB.\nAnnoncé en 2007, l’iPhone marque le début de l’internet\nmobile. De par sa nature, le stockage de données sensibles dans un objet\nportable implique la disponibilité de composants électroniques sécurisés\nadaptés (perte, vol, hacking…) tels que Secure Elements (contrôleur NFC,\ncarte SIM/USIM) ou Trusted Execution Environment (TEE).\nL’Architecture Logicielle Réseau selon REST\nDans sa thèse de doctorat, \"Architectural Styles and the Design of Network-\nbased Software Architectures\", publiée en 2000, Thomas Fielding (Université\nd’Irvine, CA, USA) définit le concept d’architecture REST (Representational\nState Transfer). L’idée est d’extraire du protocole HTTP les principes de son\nefficacité.\nIl introduit la notion d’architecture logicielle (distribuée) sous forme d’un\nassemblage de trois types d’éléments, les composants, les connecteurs et les\ndonnées:\n- Un composant (component) est un bloc abstrait d’instructions et d’états\nmachine qui traite les données reçues via son interface.\n- Un connecteur (connector) est un mécanisme abstrait qui organise la\ncommunication, la coordination, et la coopération entre composants.\n- Un datum est un élément d’information reçu ou transmis par un\ncomposant via un connecteur.\nUne architecture REST est une généralisation du WEB; ses principales\ncaractéristiques sont les suivantes :\n- Deux types d’entités les clients et les serveurs (Client-Server).\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Modèle du Cloud - NIST Special Publication 800-145", "section_path": ["Modèle du Cloud - NIST Special Publication 800-145"], "page": 13, "content": "13\n- Pas d’états machine (stateless). Les requêtes échangées sont\nindépendantes les unes des autres.\n- Usage de caches (cache) pour une meilleure efficacité du système.\n- Interface Uniforme (uniform interface) en particulier pour l’identification\net l’usage des ressources.\n- Système structuré en couche (layered system), mais présentant des\ninterfaces uniques.\n- Code à la demande (on demand code) exécuté par le client.\nDans un contexte REST la sécurité du réseau consiste à garantir l’intégrité\net la confidentialité des données échangées entre composants.\nSécurité du Cloud\nSelon la définition du NIST (Special Publication 800-145, 2011), le cloud\ncomputing est un modèle qui permet un accès efficace, omniprésent, et à la\ndemande, à un ensemble (pool) partagé de ressources informatiques\nconfigurables (telles que réseaux, serveurs, stockage, applications et\nservices). Ces ressources peuvent être provisionnées rapidement et libérées\navec un effort de gestion minimal (c’est la notion d’élasticité), et une\ninteraction réduite avec le fournisseur de services. Il est important de\nremarquer que l'infrastructure est la propriété du fournisseur de service\n(service provider).\nModèle du Cloud - NIST Special Publication 800-145\nCe modèle est composé de cinq caractéristiques essentielles, trois\nmodèles de service, et quatre modèles de déploiement.\nLes cinq caractéristiques essentielles sont: 1) la provision de ressources à\nla demande et en self service, 2) l'accès aux ressources via le réseau, à partir\nde clients légers, 3) le partage de ressources multi utilisateurs et\ngéographiquement distribuées, 4) l'élasticité des ressources disponibles, 5)\nla mesure de la consommation des ressources.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Modèle du Cloud - NIST Special Publication 800-145", "section_path": ["Modèle du Cloud - NIST Special Publication 800-145"], "page": 14, "content": "14\nUne plateforme de Cloud Computing est divisée en trois modèles de\nservices :\n- Le SaaS ou Software as a Service. Par exemple Salesforce.com met à la\ndisposition de ses clients un ensemble de logiciels dédiés à la gestion des\nentreprises. Le client accède uniquement à la configuration des applications.\n- PaaS ou Plateform as a Service. C’est un environnement (APIs, Machine\nVirtuelles7) permettant de construire/déployer des applications par exemple\nGoogle App Engine ou Microsoft Azure.\n- IaaS, ou Infrastructure as a Service. C’est typiquement un service de\nlocation de ressources telles que serveurs ou stockage de données, par\nexemple Amazon EC2. La propriété essentielle est la notion d’élasticité,\nc’est-à-dire l’adaptation dynamique des ressources à la demande.\n7 L'hyperviseur Xen a été créé à la fin des années 90, par Keir Fraser et Ian Pratt,\ndans le cadre du projet de recherche Xenoserver à l'université anglaise de\nCambridge.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Application Isolation", "section_path": ["Application Isolation"], "page": 15, "content": "15\nLes quatre modèles de déploiement du cloud comportent 1) le cloud\nprivé, 2) le cloud communautaire, 3) le cloud public, 4) le cloud hybride.\nSurface d'attaque du Cloud\nLa surface d'attaque augmente selon l'axe SaaS, PaaS, IaaS, puisque le\nnombre de ressources mises à disposition de l'utilisateur augmente.\nEléments de sécurité du Cloud\nOutre les procédures et normes de qualité, d'audit, et de conformité liées\naux locaux, aux contrôles d'accès physique, aux traitements d'incidents de\nsécurité, aux incendies et dégâts des eaux, les principaux domaines de\nsécurité de l'infrastructure du cloud sont les suivants.\nNetwork Isolation and Segmentation\n1) Network Isolation and Segmentation. Ces mesures visent la protection de\nl’infrastructure par isolation/segmentation et analyse des flux. Elles\ns'appuient sur les éléments suivants:\n– Firewalls réseau, et firewalls au niveau VM utilisateur,\n– Dispositifs IDS (Intrusion Detection System), IPS (Intrusion Prevention\nSystem), DLP (Data Leak/Lost Prevention),\n– Logs du système,\n–Détection de clients malveillants,\n–Chiffrement des informations échangées entre data centers, mais respect\nde la législation dans le pays d’accueil (Patriot Act par exemple)\nApplication Isolation\n2) Application Isolation. Ces mesures adressent l'isolation logique des\napplications hébergées. Elles s'appuient sur les éléments suivants:\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Identity and Access Management (IAM).", "section_path": ["Identity and Access Management (IAM)."], "page": 16, "content": "16\n– La Virtualisation\n– La prévention de bugs de sécurité des hyperviseurs,\n– La détection de canaux cachés (side channel) inter VM\n- Le matériel sécurisé, hyperviseur certifié (Critères Commun - CC), Unix\ndurci (SE Linux…).\nData Security\n3) Data Security. Ces mesures adressent la confidentialité des données\néchangées et stockées.\n– Protocoles de sécurité réseau TLS, IPSEC, VPN, SSH\n– Chiffrement des fichiers\n- Protection, chiffrement des bases de données Multi Tenant.\n- Gestion des clés clients sécurisées par des HSM (Hardware Security\nModule)\nIdentity and Access Management (IAM).\n4) Identity and Access Management (IAM). Ces mesures adressent le\ncontrôle d'accès à l'infrastructure du cloud.\n– Login/password,\n- One Time Password (OTP),\n– Certificats,\n– Stockage sécurisé de clés,\n–Dispositifs Hardware Secure Module (HSM).\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L'émergence du monde connecté et l'internet des objets (IoT)", "section_path": ["L'émergence du monde connecté et l'internet des objets (IoT)"], "page": 17, "content": "17\nL'émergence du monde connecté et l'internet des objets (IoT)\nRebooting the IT Revolution: A Call to Action\" (SIA/SRC), 2015\nEn 2013 plus d'un milliard de smartphones ont été vendus; ce chiffre\nmarque le basculement vers le paradigme du monde connecté. Par exemple la\nmaison connectée (smart home), la voiture connectée (connected car, Intelligent\nTransport System -ITS- ), les objets connectés (lunettes, montres, vêtements...),\nles capteurs médicaux (body area network, BAN), les immeubles intelligents\n(smart building), la ville intelligente (smart city), et de manière générale\nl'internet des objets (Internet of Things IoT).\nSelon un white paper8 de CISCO le nombre d'objets connectés était de 10\nmilliards en 2010 et pourrait atteindre 50 milliards en 2020. L'article9 évoque\nun nombre de 100,000 milliards de capteurs à l'horizon 2035, et l'émergence\ndes Cyber Physical System (CPS).\nQuelle est l’énergie nécessaire à la commutation d’un bit ? Soit N\nélectrons (de charge q =1,6 10-19 Coulomb) l’énergie (en Joule) dissipée sous\nun volt est de ½ NqV. Pour 1 volt la valeur de 10-14 J/bit correspond à 1,25\nmillion d’électrons stockés dans les capacités des transistors CMOS. Soit\nencore 100 Watts (1016 x 10-14) pour 1016 commutations par seconde de 10\nmillions de bits (107) à la fréquence 1 GHz (109).\n8 \"The Internet of Things. How the Next Evolution of the Internet Is Changing\nEverything\"\nhttp://www.cisco.com/web/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf\n9 Rebooting the IT Revolution: A Call to Action\" (SIA/SRC), 2015\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "TOP 10 des attaques IoT, OWASP 2018", "section_path": ["TOP 10 des attaques IoT, OWASP 2018"], "page": 18, "content": "18\nLe moteur de recherches SHODAN (https://www.shodan.io/) recense\nles dispositifs connectés. De nombreuses attaques/intrusions s'appuient sur\nl'usage de mots de passe par défaut.\nTOP 10 des attaques IoT, OWASP 2018\nEn 2018 la fondation OWASP a publié une liste des 10 vulnérabilités les\nplus courantes de l’internet des objets.\n1) Mots de passe faibles ou non modifiables\nUtilisation de mots de passe (\"credential\") cassables par des attaques brute\nforce, non modifiables ou publiés, associés à portes dérobées dans le micro\nlogiciel embarqué ou le logiciel client, qui permettent un accès non autorisé\naux systèmes déployés (voir par exemple https://www.shodan.io)\n2) Services réseau non sécurisés\nServices réseau non utilisés ou non sécurisés s'exécutant sur un objet\nconnecté, qui compromettent la confidentialité, l'intégrité, l'authenticité ou la\ndisponibilité de ses données, ou qui permettent un contrôle à distance non\nautorisé.\n3) Interfaces non sécurisées\nInterfaces WEB, backend API, cloud ou mobiles non sécurisées\ninteragissant avec l’objet, et permettant sa compromission ou celle des\ncomposants associés. Les faiblesses observées sont un manque\nd'authentification/autorisation, un chiffrement absent ou faible, l’absence de\nfiltrage des entrées/sorties.\n4) Absence de mécanisme de mise à jour sécurisée\nPar exemple absence de validation du micrologiciel sur l'appareil,\nprocédure de livraison non sécurisée (\"supply chain attack\"), possibilité de\nrejeu de versions antérieures (roolback), et manque de notifications des mises\nà jour.\n5) Utilisation de composants non sécurisés ou obsolètes\nUtilisation de composants de logiciels obsolètes ou non sécurisés.\nModification du système d'exploitation, utilisation de logiciels ou de\ncomposants matériels tiers provenant d'une chaîne de distribution\ncompromise.\n6) Protection insuffisante de la vie privée\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "CoAP (Constrained Application Protocol)", "section_path": ["CoAP (Constrained Application Protocol)"], "page": 19, "content": "19\nLes informations personnelles de l'utilisateur stockées sur l'objet ou dans\nl'écosystème associé, sont utilisées de manière non sécurisée, abusive ou\nsans autorisation.\n7) Transfert et stockage de données non sécurisés\nAbsence de chiffrement ou de contrôle d'accès aux données sensibles\nstockées dans l'écosystème, durant le transport ou pendant le traitement.\n8) Manque d’administration des objets.\nAbsence d’administration de la sécurité sur les objets déployés, y compris\nla gestion du parc, la gestion des mises à jour, la désactivation, la\nsurveillance des systèmes.\n9) Paramètres par défaut non sécurisés\nLes objets ou les systèmes sont livrés avec des paramètres par défaut non\nsécurisés, ou n'ont pas la capacité d’améliorer la sécurité en interdisant aux\nopérateurs de modifier les configurations.\n10) Manque de durcissement hardware\nAbsence de mesures de durcissement hardware (tamper resistant),\npermettant aux attaquants d'obtenir des informations sensibles, ou de\nprendre le contrôle local de l’objet.\nProtocoles de l'Internet of Things (IoT)\nLa RFC 7228 (\"Terminology for Constrained-Node Networks\", 2014) propose\nune classification en 3 classes des nœuds de l'IoT à ressources réduites\n- Classe C0, RAM << 10KB, code << 100KB, ces systèmes (capteurs)\nn'ont pas les ressources nécessaires pour gérer des connections sécurisées.\n- Classe C1, RAM #10KB, code #100KB, les ressources systèmes sont\nsuffisantes pour assurer des connections (TCP-UDP/IP) sécurisées selon des\nprotocoles peu complexes.\n- Classe C2, RAM #50KB, code #500KB, les ressources systèmes\nautorisent des connections à des dispositifs TCP/IP classiques (notebook,\ntablettes,…).\nCoAP (Constrained Application Protocol)\nLe protocole CoAP (Constrained Application Protocol, RFC 7252, 2014)\nsécurise (de manière optionnelle) les échanges d'information de capteurs en\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Quelques plateformes logicielles pour l'IoT", "section_path": ["Quelques plateformes logicielles pour l'IoT"], "page": 20, "content": "20\nutilisant DTLS (TLS avec un transport UDP) ou TLS. CoAP peut être\ncompris comme un proxy http, par exemple entre IPv4 et IPv6.\nLWM2M (Lightweight Machine to Machine Technical Specification)\nLWM2M (Lightweight Machine to Machine Technical Specification) est un\nenvironnement basé sur CoAP qui gère la communication entre des objets\nlogés dans des clients LWM2M et des serveurs LWM2M. Il supporte deux\nmodes de transport (UDP/IP et SMS) ainsi que quatre interfaces\nfonctionnelles, 1) le bootstrap, 2) l'enregistrement des clients avec les\nserveurs, 3) l'administration des objets, 4) les rapports d'information.\nMQTT (MQ Telemetry Transport)\nMQTT10 (MQ Telemetry Transport) d'origine IBM, est un protocole de\ntype Publish-Subscribe (bus asynchrone) sécurisé par TLS. Les nœuds\npublisher délivrent de manière asynchrone de l'information aux serveurs\nbroker de messages, les nœuds subscriber collectent ces informations.\nQuelques plateformes logicielles pour l'IoT\nL'internet des objets combine un système informatique de type embarqué\net une interface de communication telle que Wi-Fi (IEEE 802.11) ou ZigBee\n(IEEE 802.15.4).\nUn objet se décompose généralement en quatre entités logiques et\nmatérielles: 1) un circuit électronique (board) qui comporte typiquement un\nprocesseur, 2) un SOC (System On Chip) radio, 3) un système d'exploitation\nou un bootloader, 4) une pile de communication et un environnement\n(framework) applicatif. La syntaxe des messages d’application s'appuie sur\nJSON (JavaScript Object Notation), un format d'échange de données (Data\nInterchange Format) en mode texte. La structure d'un arbre JSON est décrite\npar un schéma JSON. Un document JSON comprend deux types d'éléments\nstructurels : des ensembles de paires clé (key), valeur (value), et des listes\nordonnées de valeurs. Les messages applicatifs sont échangés selon le\nparadigme REST, à l'aide des protocoles HTTP ou CoAP.\nIl existe de nombreux systèmes d'exploitation, importés de l'informatique\nclassique, ou adaptés pour des systèmes embarqués avec des ressources de\ntraitement (processing) ou de mémoire modeste, par exemple Linux, Contiki,\nRiot, Iotivity, AllJoyn, Brillo, mbed OS...\n10 IBM, Building Smarter Planet Solutions with MQTT and IBM WebSphere\nMQ Telemetry, 2012\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Quelques plateformes logicielles pour l'IoT", "section_path": ["Quelques plateformes logicielles pour l'IoT"], "page": 21, "content": "21\nDu point de vue sécurité, on constate trois grandes approches; 1) la\nsécurité au niveau MAC (Wi-Fi, ZigBee) par exemple pour les ampoules\nconnectées Philips Hue Bulbs, 2) la sécurité à l'aide des classiques protocoles\nTLS/DTLS (piles logicielles Thread ou OCF), et enfin 3) la sécurité au niveau\nde l'application (par exemple l'architecture HomeKit Accessory Protocol -\nHAP- de la société Apple).\nDe surcroit des mécanismes de contrôle d'accès utilisant des ACLs\n(Access Control List) ou des jetons (OAuth 2.0 Authentication), peuvent être\nimplémentés dans la couche applicative.\nLe transport de paquets IPv6 natifs, dont le MTU (Maximum Transmission\nUnit, taille de paquet minimale transmise sans fragmentation) est de 1280\noctets, n'est pas compatible avec la taille maximale de 127 octets des trames\nIEEE 802.15.4 (les entêtes IPv6 et TCP occupent au moins 40+20 octets). Le\nstandard 6LoWPAN11 (IPv6 Low power Wireless Personal Area Networks)\nfinalisé en 2007 (RFC 4919) définit une couche d'adaptation (adaptative layer)\nqui réalise des opérations de segmentation/assemblage et également des\nmodes de routage, internes à la couche d'adaptation (mesh-under) ou\nimplémentée dans la couche IPv6 (route-over). Un réseau 6LoWPAN\ncomprend des nœuds ordinaires (Host), des routeurs (Routers) et un routeur\nde bord (Edge Router) connecté au réseau IPv6. L'adresse IPv6 (128 bits) d'un\nnœud comporte un suffixe de 64 bit basé sur l'adresse MAC et un préfixe\nalloué selon le protocole Neighbor Discovery Router Advertisement (RA).\nLe protocole IPSEC est bien sur compatible avec cet environnement.\nCependant ZigBee conformément au standard IEEE 802.15.4 dispose\nd'algorithmes de chiffrement de trame, typiquement selon le mode AES-\nCCM 128 bits, et possède un jeu de trois clés. Un secret à long terme (Master\nKey) partagé par tous les membres du réseau, permet au terme du protocole\nSKKE (Symmetric-Key Key Establishment) d'établir une clé de ligne (Link Key)\n11 6LoWPAN: The Wireless Embedded Internet, Zach Shelby, Carsten\nBormann, Wiley, 2009\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Thread", "section_path": ["Thread"], "page": 22, "content": "22\npour les communications unicast. Cependant les réseaux ZigBee usuels\npartagent une même clé de ligne, distribuée par un nœud particulier le Trust\nCenter (TC), et chiffrée grâce au Trust Center Link Key. La clé réseau (Network\nKey) est commune à tous les participants et chiffre les trames émises en\ndiffusion (broadcast).\nThread\nLe consortium Thread définit une pile réseau s'appuyant sur 6LoWPAN\net un routage de type route-over (Distance Vector Routing). La sécurité est\ndélivrée par une couche DTLS munie du mécanisme d'authentification\nsymétrique J-PAKE (Juggling Password-Authenticated Key Exchange),\nimplémentant un mécanisme NIZK (Non-Interactive Zero-Knowledge), à l'aide\nd'échanges Diffie-Hellmann sur des courbes elliptiques, et de signature de\nSchnorr. Selon Thread un objet (joiner) s'identifie auprès d'un serveur\nd'authentification (Commissioner) localisé dans l'internet, selon un protocole\nnommé Petitioning. Cette opération est réalisée à l'aide d'une connexion\npoint à point avec un commissioner, le routeur de bord (border router) ou un\nrouteur. Le commissioner est un nœud IPv6 ou IPv4; dans ce dernier cas il\nest nécessaire de traiter les messages DTLS via un proxy. Au terme du\nprocessus de petitioning, le joiner récupère la clé de ligne ZigBee et d’autres\ninformations protégées par un mécanisme KEK (Key Establishment Key).\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Open Connectivity Foundation OCF", "section_path": ["Open Connectivity Foundation OCF"], "page": 23, "content": "23\nThread est basé sur le système d'exploitation LINUX. Des sociétés telles\nque Silicon Labs (www.silabs.com) proposent des cartes mères de\ndéveloppement. Le thermostat NEST implémente les concepts Thread.\nL'article12 met en évidence l'absence de Secure Boot et présente une attaque\npermettant de démarrer le système à partir d'une clé USB, puis de modifier\nses fonctionnalités.\nOpen Connectivity Foundation OCF\nL'architecture définie par le consortium Open Connectivity Foundation\n(OCF) est similaire à Thread relativement au réseau. Elle s'appuie sur une\npile 6LoWPAN sécurisée par le protocole DTLS. OCF introduit une entité\napplicative divisée en deux sous ensembles une couche (framework)\ndéfinissant des éléments protocolaires (messages, sécurité, opérations\n12 \"Smart Nest Thermostat: A Smart Spy in Your Home\", Grant Hernandez,\nOrlando Arias, Daniel Buentello, and Yier Jin\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "HAP", "section_path": ["HAP"], "page": 24, "content": "24\nCRUDN:Create, Read, Update, Delete, Notify...) et des profils métier tels que\ndomotique, santé, automobile, commerce. L'association IoTivity conçoit des\nlogiciels ouverts implémentant OCF et disponibles pour les systèmes\nd'exploitation Android, Tizen, Ubuntu , Windows, et Arduino!. Dans OCF le\nprotocole DTLS définit l'identité de l'objet à l'aide de mécanismes\ncryptographiques symétrique (pre-shared key) ou asymétriques (ECC, RSA,\ncertificats...); de surcroit la couche applicative supporte un mécanisme de\ntype Access Control List (ACL).\nUn objet oic (Open Interconnect Consortium) logé dans un serveur est\nidentifié par un chemin (oic://server/path). Il est associé à une requête\n(?query) renseignant diverses propriétés (property, par exemple Type \"rt\",\nInterface \"if\", name \"n\", Identity \"id\") définies par des tuples key=value:\noic://server/path?key1=value1;key2=value2.\nAinsi la propriété interface (\"oic.if.a\") fixe les opérations CRUDN\n(CREATE, RETREIVE, UPDATE) disponibles pour les actuators\n(oic://server/path?if=\"oic.if.a\"). Les ressources d'un l'objet sont également\nassociées à une liste de propriétés (tuples clé-valeur, par exemple {\"settemp\":\n10} en notation JSON) sur lesquelles s'appliquent des procédures CRUDN.\nL'URI oic://server/path?key1=value1;key2=value2 est adapté à des\nprotocoles de transport tels que HTTP ou CoAP.\nHAP\nLe modèle HAP (HomeKit Accessory Protocol) de la société APPLE\ns'appuie sur des WLAN Wi-Fi ou BLE (Bluetooth Low Energy), avec une\ncouche applicative basée respectivement sur les protocoles HTTP ou\nGATT/ATT/L2CAP (pile BlueTooth). Le paradigme de sécurité est\nsymétrique. Les objets sont associés à un code PIN de 8 digits, et authentifiés\nvia le protocole Secure Remote Password procedure (SRP, RFC 5054). Par la\nsuite un objet HAP génère une paire de clés asymétriques13 basée sur la\ncourbe elliptique Ed25519, mises en œuvre pour l'authentification et la\ncréation des clés de session. Le chiffrement utilise l'algorithme ChaCha20-\nPoly1305.\n13 iOS Security, iOS 9.0 or later, September 2015.\nhttp://images.apple.com/euro/privacy/d/generic/docs/iOS_Security_Guide.pdf\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Brillo et Weave", "section_path": ["Brillo et Weave"], "page": 25, "content": "25\nHue Smart Lighting\nLes ampoules intelligentes Hue de Philips (Hue Smart Lighting) sont\nbasées sur un réseau mesh zigBee, conforme aux spécifications ZLL (ZigBee\nLight Link). Toutes les ampoules partagent une clé maître. Un contrôleur\ndélivre aux nœuds du réseau une clé de ligne (Link Key) chiffrée à l'aide du\nMasterSecret. Il intègre une interface radio et une interface ethernet munie\nd'une pile IPv4. Côté IP les commandes sont transportées en clair par des\npaquets UDP. L'article14 présente une attaque par canaux caché de ce\nsystème qui met à profit l'absence de sécurité du contrôleur. Il introduit\négalement une classification en 4 niveaux des attaques sur les objets; 1)\nIgnorer la fonction de l'objet et introduire un code malicieux, par exemple un\nbotnet; 2) Réduire la fonction de l'objet, afin de créer un comportement\ndéfectueux; 3) Utiliser la fonction de l'objet de manière non pertinente; 4)\nEtendre la fonction de l'objet, par exemple en introduisant des canaux\ncachés.\nOn trouve dans l'article15 de Colin O’Flynn un reverse engineering du\ncontrôleur et des ampoules. Le contrôleur exécute un système d'exploitation\nlinux, son processeur intègre des accélérateurs cryptographiques AES,\n3xDES, MD5, SHA1. Les fichiers de mise à jour du système sont chiffrés par\nl'algorithme AES dont la clé est stockée dans le processeur. De même les\nSOC zigbee du contrôleur et des ampoules intègrent un accélérateur\ncryptographique AES, utilisé pour le déchiffrement des fichiers de mise à\njour. Cette analyse illustre la présence de mécanismes de sécurité matériels\ndestinés à la protection des opérations de mise à jour des objets. Les clés\ncryptographiques et algorithmes associés sont protégés par des éléments\nhardware. L'article16 analyse la sécurité du système Hue dont la principale\nfaiblesse est l'usage de jetons d'autorisation intégrés aux requêtes HTTP (en\nclair), susceptibles d'être interceptés par des malware dédiés.\nBrillo et Weave\nLa plateforme IoT Weave s'appuie sur le système d'exploitation Brillo de\nGoogle, une version allégée d'Android qui comporte un noyau LINUX de\n35Mo. La pile réseau supporte les WLANs IEEE 802.15.4, Wi-Fi, BLE. Elle\n14 Extended Functionality Attacks on IoT Devices: The Case of Smart Lights\n(Invited Paper), Eyal Ronen, Adi Shamir\n15 A Light Bulb Worm, Details of the Philips Hue Smart Lighting Design, Colin\nO’Flynn - August 1, 2016.\n16 Hacking Light bulbs: Security Evaluation of The Philips Hue Personal\nWireless Lighting System, Nitesh Dhanjani, 2013\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Intégrité des systèmes embarqués", "section_path": ["Intégrité des systèmes embarqués"], "page": 26, "content": "26\nutilise un paradigme REST transporté par les protocoles HTTPS ou XMPP,\navec des jetons d'autorisation OAuth 2.0 (RFC 6749) délivrés par des\nserveurs d'authentification (AS) Google.\nIntégrité des systèmes embarqués\nUn dispositif (\"device\" IoT) est typiquement construit à partir d’un\nprocesseur principal auquel sont reliés des capteurs et des actuateurs. Ce\ndernier peut réaliser également des fonctions de communication (Bluetooth,\nWi-Fi); dans le cas contraire un processeur de communication SoC (\"System\non Chip\") est nécessaire.\nLes objets connectés sont distribués par des canaux grand public ce qui\nrend possible la modification des logiciels embarqués (\"firmware\") par des\nattaques qualifiées de \"supply chain attacks17\". L’intégrité des micro-logiciels\net leur mise à jour (\"update\") est un pré-requis critique pour le déploiement\nde l’internet des choses. A l’IETF le groupe de travail SUIT (Software Updates\nfor Internet of Things) définit des protocoles dédiés à cet usage.\nUn processeur d’objet est équipé de mémoires non volatiles de type ROM\n(non effaçable) ou FLASH (effaçable). Plus précisément pour les mémoires\nROM on utilise des technologies de type OTP (One Time Programmable)\nbasées sur des fusibles à usage unique. La programmation de mémoire\nFLASH implique la mise en d’œuvre d’un programmeur et d’un protocole\nparticulier, tel que JTAG (Joint Test Action Group), protocole parallèle\n(utilisant un ensemble de signaux dédiés), ou SPI (Serial Peripheral Interface).\nSPI est un protocole très répandu basé sur deux canaux séries et quatre\nsignaux: SCLK (serial clock), MOSI (master out slave in), MISO (master in\nslave out), et SS (slave select). Lors de la production les logiciels sont chargés\ndans les mémoires non volatiles. Afin de permettre des mises à jour\nlogicielles un composant particulier le bootloader constitue le premier\nélément d’une chaîne de chargement. Par exemple le bootloader comporte\n17 Voir par exemple https://docs.microsoft.com/en-us/windows/security/threat-\nprotection/intelligence/supply-chain-malware\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "FLASH Disk", "section_path": ["FLASH Disk"], "page": 27, "content": "27\nun pilote USB et un interpréteur de commande; il peut également intégrer\ndes procédures de sécurité permettant la vérification de signature avec une\nclé publique ou le déchiffrement de données avec une clé symétrique (par\nexemple selon l’algorithme AES-CCM).\nSelon les capacités du processeur le bootloader est logé en ROM ou en\nFLASH.\nVoici quelques cas pratiques qui illustrent les attaques par défaut\nd’intégrité.\nFLASH Disk\nLes disques FLASH (\"clés USB\") sont basés sur des contrôleurs dédiés\n(FLASH Controller) dont les spécifications ne sont généralement pas publiques.\nPar exemple le contrôleur PS2251-33 de Phison Electronics Corporation, illustré\npar la figure ci-dessous comporte une ROM interne et ROM externe qui\nstockent un bootloader.\nDes sites dédiés (flashboot.ru, www.usbdev.ru...) gèrent des bases de\ndonnées relatives aux micrologiciels des clés USB et fournissent les outils\nnécessaires à leur chargement. Le contenu des mémoires peut être protégé\npar un mot de passe utilisateur18 selon une procédure gérée par le\nmicrologiciel. En 2014 une équipe de chercheurs19 à démontré à la\nconférence Black Hat des modifications de micrologiciel réalisant\nl’émulation de clavier (attaque Key Loger) ou de cartes réseau (attaque\nProxy). Les sites20 21 détaillent des mises en œuvre telles attaques.\n18 Jago, D., 2018, Security analysis of USB drive, Master’s thesis report,\n19 Nohl, K., KriBler, S., Lell, J. 2014. \"BadUSB - On Accessories that Turn\nEvil\", Blackhat 2014 USA\n20 https://github.com/brandonlw/Psychson\n21 https://www.pentestingshop.com/recover-a-usb-stick\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Dongle Wi-Fi", "section_path": ["Dongle Wi-Fi"], "page": 28, "content": "28\nDongle Bluetooth\nLa famille de jetons bluetooth HC05/HC06 est basée sur le\nSoC BlueCoreTM-External (CSR BC417143), produit par la société\nCambridge Silicon Radio rachetée en 2015 par Qualcomm. Le SoC\nest associé à une mémoire FLASH externe, dont le contenu peut\nlu ou chargé avec le logiciel Blue Flash Software version 2.62, qui\nnécessite un adaptateur USB dédié. La documentation du SoC\nindique qu’une interface SPI permet de programmer le premier\nMbit de mémoire FLASH, et suggère de mettre en œuvre un\nbootloader. Ce dernier assure par la suite le chargement de l’espace\nmémoire. La référence22 commente un reverse engineering du logiciel Blue\nFlash, et propose une bibliothèque permettant le chargement et la lecture du\nmicro-logiciel.\nSoC CSR BC417143 (à gauche) et dispositif de chargement du firmware (à droite)\nDongle Wi-Fi\nLa puce ESP8266 est un SoC Wi-Fi de faible coût, fabriqué par la société\nEspressif Systems. Il est basé sur un microprocesseur RISC 32 bits de la société\nTensilica, fonctionnant à 80 MHz.\n22 Willem, F., 2016, CSR BlueCore USB SPI programmer/debugger,\nhttps://github.com/lorf/csr-spi-ftdi\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "AVR", "section_path": ["AVR"], "page": 29, "content": "29\nAucune spécification détaillée n'est disponible publiquement.\nNéanmoins, certains sites Web fournissent des informations sur les\nmémoires physiques. Le SoC intègre une ROM de 64 Ko, un ensemble de\nRAM (environ 80 Ko, y compris le cache des instructions), 80 Ko de mémoire\nDRAM pour les données utilisateur et une mémoire FLASH externe (jusqu'à\n16 Mo). Certains ESP8266 supportent un boot sécurisé, c’est-à-dire que le\nmicrologiciel stocké dans la FLASH est chiffré par une clé AES, gravée dans\nune mémoire OTP.\nLa ROM contient un bootloader qui réalise à l’aide d’une fonction UART\net d’un logiciel dédié (ESP FLASH Download Tool) le chargement du\nmicrologiciel.\nEspressif Systems fournit un kit de développement logiciel sans OS (SDK\nNONOS) comportant des bibliothèques compilées (notamment une pile\nTCP/IP) et des codes sources ouverts. La plupart des modules ESP8266 sont\nfabriqués par la société Ai-Thinker sous la marque \"ESP-xx\".\nAVR\nAVR est une\nfamille de\nmicrocontrôleurs 8\nbits RISC\ncommercialisés par\nla société ATMEL\nrachetée en 2016 par\nMicrochip\nTechnology.\nL’architecture AVR\na été conçue en 1992\npar deux étudiants\ndu Norwegian\nInstitute of\nTechnology (NTH),\nAlf-Egil Bogen et\nVegard Wollan. Ces\nprocesseurs, en\nparticulier utilisés par l’environnement Arduino, sont équipés de mémoires\nFLASH, RAM, et EEPROM. ATMEL a développé un bootloader associé au\nprotocole DFU (Device Firmware Upgrade) et mis en œuvre par le logiciel\nATMEL FLIP.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "SCADA", "section_path": ["SCADA"], "page": 30, "content": "30\nLa sécurité des puces AVR est assurée par deux types de registres: les\nverrous (locks) et les fusibles (fuses). Les verrous sont réinitialisés grâce aux\ncommandes envoyées via des interfaces de programmation telles que SPI. Ils\ngèrent la politique d'accès à la mémoire FLASH (opérations de lecture et\nd'écriture), la politique de sécurité des fusibles (lecture et écriture), et\nl'utilisation optionnelle d’un bootloader. Les fusibles ne sont pas effacés par\nla commande de réinitialisation (reset) SPI; ils sont modifiés par des\ncommandes dédiées. Ils contrôlent certaines fonctionnalités de\nprogrammation telles que l'utilisation de la broche RESET ou du protocole\nSPI, ainsi que d'autres paramètres physiques relatifs aux horloges et tensions\nlogiques.\nEn l’absence de ROM, il n’est pas possible de désactiver définitivement\nles opérations d’écriture FLASH. En d'autres termes, il est toujours possible\nd'effacer et de télécharger du code dans la mémoire FLASH. Des outils\nouverts telles que AvrDude (AVR Downloader/UploaDEr) ou gratuits\n(Atmel Studio) sont dédiés à la programmation des processeurs AVR.\nSécurité des Systèmes Industriels\nSCADA\nL'industrie, en particulier le contrôle des processus industriels (usines...)\nutilise également des technologies connectées. Par exemple le système de\ncontrôle et d'acquisition de données SCADA23 24(Supervisory Control And\nData Acquisition), comporte des dispositifs de contrôle tels que PLC\n(programmable logic controller) ou RTU (remote telemetry unit) communiquant\nvia les protocoles MODBUS ou DNP3, fonctionnant en mode Master/Slave\n(sur des liaisons séries RS-232, RS-485) ou Client/Server (TCP/IP).\n23 http://www.schneider-\nelectric.com/solutions/ww/fr/med/20340568/application/pdf/1485_se-whitepaper-\nletter-scadaoverview-v005.pdf\n24 Practical Modern SCADA Protocols:\nDNP3, 60870.5 and Related Systems, ISBN 07506 7995\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "STUXNET, une arme logicielle", "section_path": ["STUXNET, une arme logicielle"], "page": 31, "content": "31\nSTART ADDRESS FUNCTION DATA LRC END\nCHECK\n1 octet 2 octets 2 octets N octets 2 octets CR LF\nStructure d'un message MODBUS (pas d'éléments de sécurité)\nExemple de système SCADA.\nSTUXNET, une arme logicielle\nLe vers informatique Stuxnet découvert en 2010 a permis25 la destruction\nde machines industrielles (un millier de centrifugeuses...) en attaquant la\n25 Dissecting Stuxnet, Stanford University,\nhttps://www.youtube.com/watch?v=DDH4m6M-ZIU\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Car Hacking.", "section_path": ["Car Hacking."], "page": 32, "content": "32\nplateforme SCADA WinCC/PCS7 de Siemens et en reprogrammant des\nPLCs (automates S7), depuis des machines Windows préalablement\ncorrompues (des serveurs winCC). Le cœur de l'attaque s'appuie sur des\ndéfauts Zero-Days Windows et sur la mise à jour logicielle non sécurisée du\nPLC S7-300.\nCar Hacking.\nUne automobile moderne comporte un ensemble de modules\nélectroniques (une cinquantaine) dénommés Electronic Control Units (ECUs)\nconnectés en réseau et destinés au contrôle et à la gestion du véhicule (freins,\ndirection, pneus, ...).\nExemple de CAN-bus reliant trois ECUs\nLes ECU sont reliés à un ou plusieurs bus conformes au standard\nController Area Network (CAN), ISO 11898.\nUn paquet CAN Data (1 octet de donnée)\nUn paquet CAN comporte un identifiant (11 ou 29 bits, mais\ngénéralement 11bits), un champ longueur de données, des données (de 0 à 8\noctets) et un CRC de 15 bits. Les paquets sont émis en diffusion sur les bus\nCAN, ils sont traités ou ignorés par les ECUs en fonction de la valeur de leur\nidentifiant. Le débit usuel du CAN bus est de 500 Kbit/s (soit 2µs par bit).\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Car Hacking.", "section_path": ["Car Hacking."], "page": 33, "content": "33\nLes deux types principaux de paquets CAN sont les trames DATA, et les\ntrames REQUEST. Ces dernières sont une requête d'émission pour un ID\nparticulier, le champ longueur indique dans ce cas la taille des données\nattendues, et le bit RTR (Remote Transmission Request) est positionné.\nLes données sont codées selon un format propriétaire ou en conformité\navec des standards tels que ISO-TP ou OBD-II (On Board Diagnostics). Des\npaquets de diagnostic sont utilisés uniquement à des fins de maintenance.\nConformément aux normes ISO-TP (ISO 15765-2) l'entête des données\n(un ou deux octets) indique le type de trame (trame unique, première trame\nd'un bloc, trame d'un bloc, gestion de flux) et la longueur des informations.\nLe premier octet d'information est l'identifiant de service (Service ID)\ndéfini par le standard for ISO 14229. Par exemple Security Access (0x27) est\nune procédure de contrôle d'accès basée sur un mécanisme de défi/réponse\nutilisant un secret partagé (mot de passe...) utilisée pour les opérations de\nmaintenance. Cependant il est important de remarquer que les échanges\nfonctionnels ne sont pas sécurisés (pas de chiffrement ni contrôle\nd’intégrité).\nMécanisme de segmentation selon le standard ISO_TP\nLa norme OBD-II (standard SAE J/1979) date des années 1990; elle est\nobligatoire en Californie depuis 1996. Elle permet la lecture des Diagnostic\nTrouble Codes (DTC) standardisés ou propriétaires, ainsi que les informations\ntemps réel en provenance de capteurs connectés aux calculateurs de bord.\nElle s'appuie sur des trames CAN et le standard ISO-TP. Le protocole\ncomporte des messages de requête et de réponse. Le premier octet d'une\nrequête indique par le mode (01 par exemple) et le deuxième l'identifiant de\nprotocole (PID). En cas de succès la réponse débute par l'octet mode+0x40,\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques récentes sur les voitures connectées", "section_path": ["Attaques récentes sur les voitures connectées"], "page": 34, "content": "34\nsuivi de l'octet PID, et de données. La collecte du régime moteur (tr/mn) est\nillustrée ci dessus:\nRequête: 7DF 08 02 01 0C [6 padding bytes]\nRéponse: 7E8 08 04 41 0C 11 42 [3 padding bytes]\nLe CAN-ID 7DF est une adresse de diffusion, le mode 01 signifie \"Show\ncurrent data\" , le PID 0C désigne le régime moteur.\nL'ECU qui possède l'information (CAN-ID = 7E8) délivre une réponse\navec le mode 41 (0x40 + 1) et le PID de la requête, les deux derniers\nreprésentent l'information demandée.\nAttaques récentes sur les voitures connectées\nL'article26 décrit des attaques par injection de paquets en mode\nmaintenance ou fonctionnel; ces dernières permettent de contrôler entre\nautres, les freins, la direction, ou le régime moteur.\nExemple d'injection de paquet CAN depuis une prise OBD-II.\nEn 2015 l'article27 décrit une attaque via le réseau cellulaire SPRINT\nvisant une Jeep Cherokee. Le véhicule comporte un dispositif multimédia\n26 Chris Valasek, Charlie Miller \"Adventures in Automotive Networks and\nControl Units\", 2014\n27 Charlie Miller, Chris Valasek \"Remote Exploitation of an Unaltered Passenger\nVehicle\", 2015\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques récentes sur les voitures connectées", "section_path": ["Attaques récentes sur les voitures connectées"], "page": 35, "content": "35\n(auto radio, bluetooth, ...) nommé UCONNECT équipé d'un processeur\nTexas Instruments OMAP-DM3730, intégrant un système d'exploitation\nQNX. Cet équipement est connecté au bus CAN à l'aide d'un processeur\nRenesas V850; il possède également un port TCP 6667 ouvert sur le réseau\ncellulaire réalisant un service D-Bus destiné aux communications inter\nprocessus (IPC) et à l'appel de procédures distantes (RPC). L'exploit consiste\nà injecter un firmware modifié pour le coprocesseur V850 en exploitant une\nfaille de type \"buffer overflow\". Par la suite il devient possible d'injecter à\ndistance des paquets CAN à partir du port TCP 6667.\nLes deux causes de cette attaque sont d'une part l'existence d'un Buffer\nOverflow et d'autre part un mécanisme de mise à jour logicielle non sécurisé.\nL’article28 détaille des attaques réalisées à l’aide d’une sonde CAN\nréalisée à partir d’un Arduino et d’un contrôleur CAN bus MCP2515.\nIllustration d’une sonde CAN\nCette sonde permet\nd’afficher des informations\nerronées sur le tableau de bord\n(vitesse,…), de modifier le\ncompteur kilométrique, de\ncouper l’injection de carburant\ndans le moteur (vitesse <\n20Km/h), de différer le\nfreinage de 1,5s pour de faible\nvitesse (< 2Km/h), et\nd’initialiser la programmation\nde l’ECU (moteur à l’arrêt) ce qui empêche le véhicule de démarrer.\n28 Pascal Urien, \"Designing Attacks Against Automotive Control Area Network\nBus and Electronic Control Units\", 2019 16th IEEE Annual Consumer\nCommunications & Networking Conference (CCNC)\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Surface d’attaque du véhicule connecté autonome", "section_path": ["Surface d’attaque du véhicule connecté autonome"], "page": 36, "content": "36\nDe manière plus générale le rapport29 du sénateur Américain Edward J.\nMarkey met en évidence les failles de sécurité des points d'entrée des\ncommunications sans fil (Wireless Entry Points) dans les véhicules du\nmarché, et les risques d'intrusion associés. \"In a 2013 study that was funded\nby the Defense Advanced Research Projects Agency (DARPA), two\nresearchers demonstrated their ability to connect a laptop to two different\nvehicles’ computer systems using a cable, send commands to different ECUs\nthrough the CAN, and thereby control the engine, brakes, steering and other\ncritical vehicle components.\"\nSurface d’attaque du véhicule connecté autonome\nUn véhicule de nouvelle génération propose un ensemble de\nfonctionnalités, telles que:\n- Contrôle du véhicule via les messages CAN\n- Contrôle d’accès physique (clés)\n- Diagnostiques OBDII\n- Recharge des batteries\n- Mises à jour logicielles\n- Advanced Driver Assistance System – ADAS\n- Conduite autonome (SAE J3016) : 6 niveaux de 0 à 5\n- V2X services (V2C Vehicule to Vehicule, V2I Vehicule to Infrastructure)\nUn véhicule de nouvelle génération possède de multiples interfaces\nréseaux:\n- CAN Bus & ECU (Electronic Control Units)\n- LAN (Local Area Network): Ethernet\n- WLAN (Wireless Area Network): Wi-Fi\n- Dedicated Short-Range Communications (DSRC) pour les services V2X\n- LPAN (Local Area Network): Bluetooth\n29 Senator Edward J. Markey, \"Tracking & Hacking:Security & Privacy Gaps\nPut American Drivers at Risk\", 2015\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Exemple d’architecture de communication d’une TESLA", "section_path": ["Exemple d’architecture de communication d’une TESLA"], "page": 37, "content": "37\n- Radio Low Frequency (~150KHz) et Ultra High Frequency (~400MHz)\n- LTE (Long Term Evolution) 4G, 5G\n- Internet\n- GPS (Global Positioning System)\nExemple d’architecture de communication d’une TESLA\nL’infrastructure de communication d’une TELSA se décompose\nschématiquement en trois niveaux:\n- Le réseau internet et le data center du constructeur (Mothership) qui\ngère la flotte de véhicule. Chaque véhicule, identifié par un VIN (Vehicule\nIdentification Number), possède un certificat, qui permet d’établir au terme\nd’une procédure de mutuelle authentification un VPN avec les serveurs\ndistants)\n- Un réseau local Ethernet Infotainment (Information +Entertainment). Ce\ndernier gère des interfaces pour Internet (Wi-Fi, réseau cellulaire), Bluetooth\net CAN-Bus. Il comporte trois nœuds, CID (Center Information Display,\nUnix) , IC (Instrument Coaster, Unix), et passerelle CAN-BUS (RTOS).\n- Un réseau CAN-BUS. Un système Autopilot réalise les services Full Self\nDriving (FSD); ce dernier directement connecté aux radars et cameras; il gère\négalement un lien Ethernet Gigabit avec la passerelle.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Méthodes de défense", "section_path": ["Méthodes de défense"], "page": 38, "content": "38\nTypes d’attaques30\nMéthodes de défense31\n30 Adi Karahasanovic & All, \"Adapting Threat Modeling Methods for the\nAutomotive Industry\" - 15th ESCAR Conference, Berlin 2017\n31 Mahdi Dibaei & All, \"Attacks and defences on intelligent connected vehicles:\nA survey\", 2020\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Introduction aux techniques Deep Learning (DL)", "section_path": ["Introduction aux techniques Deep Learning (DL)"], "page": 39, "content": "39\nDeep Learning & Attaques\nIntroduction aux techniques Deep Learning (DL)\nIn 1943, Warren McCulloch and Walter Pitts ont conçu32 le premier\nréseau de neurones, par analogie avec le cerveau humain.\nL’approximation d’un neurone (j) s’écrit Yj = f(∑ Wij Xi – θj), Xi étant les\nentrées (n entrées), θj le seuil, et f la fonction de d’activation. La sortie de f\nvarie entre -1/0 et 1, par exemple c’est la fonction de Heaviside H(x),\nReLU(x), ou la fonction sigmoïde.\n32 Warren S. McCulloch and Walter Pitts, Walter \"A logical calculus of the ideas\nimmanent in nervous activity\" The bulletin of mathematical biophysics, 5(4), 115-\n133, (1943)\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Introduction aux techniques Deep Learning (DL)", "section_path": ["Introduction aux techniques Deep Learning (DL)"], "page": 40, "content": "40\nDans un espace affine euclidien à N dimensions, le neurone définit deux\nzones séparées par un hyperplan (P), P:{M, OM n= θ }, n=(W ,…,W )\n1 n-1\nLe neurone de McCulloch & Pitts peut réaliser les fonctions AND ou OR,\nmais pas le ou exclusif (XOR).\nFrank Rosenblatt a proposé33 en 1958 un algorithme d’apprentissage\nsupervisé (le Perceptron), implémenté pour la reconnaissance d’image.\nEn 1986, l’article34 décrit le premier algorithme concept d’apprentissage\npar un algorithme de rétro propagation d’erreur (qui deviendra par la suite\nla méthode ‘apprentissage par descente de gradient).\nL’article35 a démontré en 1989, qu’un réseau de neurones à trois couches\n(input layer, hidden layer, output layer) peut approximer toute fonction\nY=F(X,W).\n33 Frank Rosenblatt \"The Perceptron: A Probabilistic Model for Information\nStorage and Organization in the Brain,\" Psychological Review, 65(6), 386-408.\n1958\n34 Rumelhart, D.E., Hinton, G.E. and Williams, R.J. \"Learning representations\nby back-propagating errors,\" Nature, 323, 533-536., 1986\n35 Kurt Hornik, Maxwell Stinchcombe, Halbert White, \"Multilayer feedforward\nnetworks are universal approximators” Neural Networks, 2(5), 359-366, 1989\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques des systèmes Deep Learning", "section_path": ["Attaques des systèmes Deep Learning"], "page": 41, "content": "41\nUn réseau à N couches Y=F(X,W) possède E entrées (X) et S sorties (Y)\nYj= Fj(X,W) et W poids (Wk). Les données d’’apprentissage (training data)\nsont un ensemble de m vecteurs (X,Y). Un algorithme (la descente de\ngradient) produit les poids W du modèle, en minimisant les erreurs selon\nune fonction de coût, par exemple ∑ ∑ (Yj,i - Fj(Xi,W))2\nLes réseaux CNN (Convolutional Neural Network) sont inspirés des\ntravaux David H. Hubel and Torsten N. Wiesel (prix Nobel en Physiologie\nou Médecine en 1981), relatifs au traitement de l’image par le cerveau\nhumain, selon un réseau de neurones organisé en trois couches, V1, V2, V4.\nPar exemple le réseau LeNet536, dédié à la reconnaissance de caractères,\npublié en 1998, comportait 60.850 paramètres d’apprentissage et 340.918\nconnections.\nAttaques des systèmes Deep Learning\nLe modèle Y=F(X,W) est réalisé par des processeurs GPU ou des circuits\nintégrés dédiés.\n36 Lecun, Y.; Bottou, L.; Bengio, Y.; Haffner, P., \"Gradient-based learning\napplied to document recognition\", Proceedings of the IEEE. 86 (11): 2278–2324,\n1998\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques des systèmes Deep Learning", "section_path": ["Attaques des systèmes Deep Learning"], "page": 42, "content": "42\nL’article37 présente quelques attaques utilisant des techniques Deep\nLearning, en boîte blanche ou boîte noires. Il propose la classification\nsuivante :\n- Les attaques par empoisonnement, (poisoning attack), des données\nmalveillantes sont introduites dans les données d’apprentissage\n- Les attaques par évasion (evasion attack), des données malveillantes sont\nprésentées aux entrées du réseau\n-Les attaques par inversion (inversion attack) visent à reconstruire les\ndonnées d’apprentissage à partir du modèle\n-Le vol des données d’apprentissage (data set) ou du modèle\n37 Ho Bae, Jaehee Jang, Dahuin Jung, Hyemi Jang, Heonseok Ha, Hyungyu Lee,\nand Sungroh Yoon, \"Security and Privacy Issues in Deep Learning\", 2020\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Bitcoin", "section_path": ["Bitcoin"], "page": 43, "content": "43\nL’émergence des Crypto-Monnaies, Blockchain, Smart Contracts\nLa blockchain est un concept très novateur qui permet de partager des\ninformations sans tiers de confiance. Elle s’appuie sur un réseau P2P\nutilisant des protocoles dédiés. Des transactions signées sont collectées par\nles nœuds du réseau, qui vérifient leur authenticité et leur cohérence, et les\nrassemblent dans un bloc. Ce bloc est lié au précédent selon un mécanisme\nde consensus tel PoW (Proof of Work) ou PoS (Proof of Stake).\nBitcoin\nLes principes de la crypto monnaie Bitcoin38 ont été\ndéfinis en 2008 par l'article39 écrit sous le pseudonyme de\nSatoshi Nakamoto. Cette monnaie numérique repose sur\ntrois piliers, 1) l'émission de valeur basée sur un\ninvestissement en matériel informatique et sur la\nconsommation d'énergie, 2) la gestion de transactions\n(transfert de valeurs) authentifiées par des signatures cryptographiques , 3)\nla publication des transactions dans des listes de blocs chainés (la\nblockchain) certifiés par les mineurs grâce à un mécanisme de Proof of Work\n(PoW), impliquant une dépense de temps CPU et d'énergie électrique.\nDans le monde bancaire classique Bob possède un compte. Lors d'une\ntransaction par carte bancaire avec Alice, il est identifié/authentifié par sa\ncarte, un cryptogramme est acheminé via le réseau des cartes bancaires vers\nsa banque (issuer) qui délivre une autorisation.\nDans un contexte blockchain bitcoin Bob possède une clé privée (un\nnombre de 32 octets -x-) et un identifiant (dénommé adresse, @bob) dérivé\nde sa clé publique (sur la courbe elliptique secp256k1, gx). Les transactions\nsont publiques et enregistrées/publiées dans un livre de compte (ledger)\ninstancié par une série de blocs (la blockchain). Le crédit de @Bob et les\ntransactions sont publiques et certifiés par la blockchain. Un avoir de @Bob\nest identifié par un montant, le hash (identifiant) d'une précédente\ntransaction de versement, nommé UTXO (Unspent Transaction Output), et\nl’index du versement dans cette transaction. Bob réalise un transfert\nd'UTXO au bénéfice d'Alice identifiée par son adresse @Alice; il peut (doit)\nattribuer un pourboire (fee) au mineur, qui est déduit de l'UTXO. Il signe la\ntransaction et la transfère au système blockchain.\n38 Andreas M. Antonopoulos, \"Mastering Bitcoin\", O'REILLY, 2015\n39 Satoshi Nakamoto, \"Bitcoin: A Peer-to-Peer Electronic Cash System.\", 2008\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Bitcoin", "section_path": ["Bitcoin"], "page": 44, "content": "44\nToutes les 10 minutes (en moyenne) les transactions sont assemblées dans\nun nouveau bloc (soit 144 blocs par jour environ). Un entête bloc (header)\ncomporte entre autre le hash du bloc précédent, la racine d'un arbre de\nMerkle assemblé à partir des transactions, et un nombre aléatoire (nonce) qui\nréalise une solution à un problème difficile de hash.\nSoit H la fonction H(x)=sha256((sha256)(x)).\nLe mineur résout le problème :\nH(nonce, header) < (65535 << 208) / difficulty\nL'entropie du calcul est voisine de 32+log (difficulty), soit 75 bits en 2019.\n2\nLa difficulté est ajustée tous les 2016 blocs, soit environ toutes les deux\nsemaines (2016/144).\nLa probabilité ∆p de miner un bloc en temps ∆t selon une difficulté D\n(nombre de calculs) et un hash rate h(t) (nombre de calculs par seconde)\ns’écrit:\n∆p = ∆t x h(t)/D\nIl en résulte que la densité de probabilité de minage d’un bloc est une\nfonction exponentielle:\nEn particulier la probabilité de miner un bloc en un temps inférieur à t\ns’écrit\nCette relation illustre les attaques à 51% dans lesquelles deux puissances\nde minage s’affrontent λ1 = h1(t)/D et λ2= h2(t)/D, si λ1 est associée à la\npuissance de minage honnête, on obtient pour λ1 >= λ2, p1(t) >= p2(t).\nUn mineur utilise une machine spécialisée (le rig) pour accomplir cette\nopération. En 2021 le système ASIC AntMiner S17 réalise 73 TH/s (73000\nmilliards de calculs H(x) par seconde), pour un prix de 2000$, et une\nconsommation électrique de 2920 Watts, soit environ 0,04 Joule/Gh/s\nUne difficulté de 276 (en avril 2021) toutes les 10 minutes (#29 secondes)\nimplique un hash rate d'environ 150 106 TH/s (267). La consommation\nélectrique journalière est de l'ordre de 0,16 TWh (60TWh / an, la production\nfrançaise d’énergie est de 540 TWh / an) pour un cout de 24 Million€ (avec\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Ethereum et smart contract", "section_path": ["Ethereum et smart contract"], "page": 45, "content": "45\nun prix de 0,15€/KW/h). Le mineur reçoit une prime (reward) lorsqu'il\ngagne la compétition du minage, cette prime est de 6,25 BTC en 2021, soit\n900 BTC par jour, 54 Million€ pour un cours de 60000 $/BTC. Le parc de rig\nest d’environ 2,4 million d’unités.\nLa première transaction d’un bloc (le coinbase) indique l’adresse à laquelle\nest versée la prime de minage.\nL'idée de création de monnaie du bitcoin s'inspire de l'image d'une mine\nd'or. Les blocs sont minés à un rythme constant (144/jour), et associés à une\nprime (la richesse du minerai) qui est divisée par deux (le minerai devient\nmoins riche en fonction de la profondeur) tous les 210,000 blocs (soit 4 ans).\nLa prime initiale en 2009 était de 50 BTC. Le bitcoin est divisé en 108 satoshis.\nPour ces raisons le nombre de Bitcoin émis en 33 ans est limité à 21 millions\n(210,000 x 50 x 2), dont la moitié (10,5 millions) ont été crées au terme des\nquatre premières années de vie du système (soit fin 2012).\nExemple d’une transaction Bitcoin\nEthereum et smart contract\nLe concept de la blockchain Ethereum a été introduit40 par Vitalik\nButerin in 2013. Par la suite le projet s'est développé dans une société suisse\n(Ethereum Switzerland GmbH), et une fondation à but non lucratif (Stiftung\nEthereum). Le système est opérationnel depuis le 30 juillet 2015. Cette\nblockchain est associé à une crypto monnaie, l'Ether (1 Ether=2000 $ en avril\n2021), qui est divisé en 1018 Weis. Dans le minage du bitcoin les machines\n40 Vitalik Buterin, \"A Next-Generation Smart Contract and Decentralized\nApplication Platform\", 2013; https://github.com/ethereum/wiki/wiki/White-Paper\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Ethereum et smart contract", "section_path": ["Ethereum et smart contract"], "page": 46, "content": "46\nrigs interprètent des scripts de signature du payeur et d'identification de la\nclé publique du payé. Le langage utilisé n'est pas Turing complet, car il ne\npossède pas de boucles. Ethereum41 introduit un langage Turing complet,\nbasé sur des instructions identifiées par un octet. Ce langage permet\nd'intégrer à des transactions l'exécution (appels) de programmes nommés\nSmart Contracts.\nDe manière similaire au bitcoin les utilisateurs sont identifiés par une\nadresse dérivée d'une clé publique (courbe elliptique secp256k1), et\npossèdent une clé privée utilisée pour la signature des transactions. Les\nblocs sont minés toutes les 14,0 secondes, gratifiés d'une prime (reward) de 2\nEthers (auparavant 5 puis 3 ethers), à laquelle s'ajoute la notion d'oncle (une\nprime de (7-rang) x reward/8 d'Ether, avec rang >=0). La production de\nmonnaie est donc constante (6172 blocs/jour, 12,344 Ethers/jour).\nContrairement au bitcoin, Ethereum stocke les transactions dans la\nblockchain. Ethereum utilise un Proof of Work (PoW) basé sur la résolution\nd'un problème difficile (Ethash, dérivé de la procédure sha3-512), mais\npropose comme alternative à la consommation d'énergie, un algorithme de\nconsensus nommé Proof of Stake. Ethereum revendique la définition d'un\nalgorithme PoW difficile à intégrer dans des ASICs, afin de maintenir un\nhash rate modeste (620 TH/s en 2021). Une machine Radeon RX 480, d'un\nprix de 540$, consomme 165W et produit 30MH/s; soit une consommation\nélectrique totale journalière de 71,000,000 KWh pour un cout de 10,7\nMillion€.\nF8 6B // list length= 107 bytes\n80 // nonce = null (zero value)\n85 04E3B29200 // gazPrice= 21,000,000,000 Wei)\n82 9C40 // gazLimit= 40,000 Wei\n94 777A07BAB1C119D74545B82A8BE72BEAFF4D447B //Recipient\n87 2386F26FC10000 // value= 10,000,000,000,000,000 Wei\n80 // data = null\n1C // signature recovery parameter = 28\nA0 F1DD7D3B245D75368B467B06CAD61002 // r value\n67031935B7474ACB5C74FE7D8C904097 // 32 bytes\nA0 772D65407480D7C45C7E22F84211CB1A // s value\nDF9B3F36046A2F93149135CADBB9385D // 32 bytes\nExemple de transaction Ethereum\nLes contrats sont stockés par des adresses dédiées. Chaque instruction de\nla machine virtuelle est facturée 1 Gas. La côte proposée du Gas en Ether\n41 \"Ethereum: A Secure Decentralised Generalised Transaction Ledger\", août\n2015 - Yellow Paper\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Exemple de contrats: les jetons ERC20", "section_path": ["Exemple de contrats: les jetons ERC20"], "page": 47, "content": "47\n(Gas Price) est insérée dans la transaction, ainsi que le coût maximum de\nl'exécution du contrat (Start Gas).\nExemple de contrats: les jetons ERC20\nSelon la recommandation ERC20 un jeton est associé à une adresse de\ncontrat implémentant l’interface ERC20. Lors de la création le nombre de\ndécimal (n) est défini, soit 1 jeton = 10n unités.\nfunction name() public view returns (string)\nfunction symbol() public view returns (string)\nfunction decimals() public view returns (uint8)\nfunction totalSupply() public view returns (uint256)\nfunction balanceOf(address _owner) public view returns (uint256 balance)\nfunction transfer(address _to, uint256 _value) public returns (bool success)\nfunction transferFrom(address _from, address _to, uint256 _value) public\nreturns (bool success)\nfunction approve(address _spender, uint256 _value) public returns (bool\nsuccess)\nfunction allowance(address _owner, address _spender) public view returns\n(uint256 remaining)\nevent Transfer(address indexed _from, address indexed _to, uint256 _value)\nevent Approval(address indexed _owner, address indexed _spender,\nuint256 _value)\nLes transferts de jeton sont réalisés par des procédures dédiées dont l’image\nbinaire est insérée dans le champ data de la transaction, dont l’adresse de\ndestination est celle du contrat ERC20, par exemple:\na9059cbb\n00000000000000000000000005a8e2728f64618c2119a8fd78078a9ade19abe8\n0000000000000000000000000000000000000000000000000de0b6b3a7640000\nFunction: transfer(address to, uint256 tokens)\nMethodID: 0xa9059cbb = sha3[\"transfer(address,uint256)\"]\nMethodID: A9059CBB\n[0]: 00000000000000000000000005a8e2728f64618c2119a8fd78078a9ade19abe8\n[1]: 0000000000000000000000000000000000000000000000000de0b6b3a7640000\nDans cet exemple la procédure la transaction invoque la méthode\ntransfer() d’un contrat ERC20, le premier paramètre est l’adresse du\nbénéficiaire, le deuxième paramètre est la valeur du token soit\n1.000.000.000.000.000.000 (18 décimales).\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité des protocoles de communication et des réseaux", "section_path": ["Sécurité des protocoles de communication et des réseaux"], "page": 48, "content": "48\nSécurité des Applications Distribuées, Emergence de la Cyber Sécurité\nLa sécurité globale s’appuie le triptyque:\n1) La sécurité des applications clientes et serveurs,\n2) La sécurité des plateformes informatiques qui exécutent ces\napplications, et qui comportent deux composants:\n- Le système d'exploitation\n- Le hardware\n3) la sécurité des protocoles de communication et du réseau qui\ntransportent les messages d'applications\nSécurité des applications\nUne application est une suite d'instructions (consommation de temps\nCPU) associée à contexte mémoire, qui s'appuie sur des ressources fournies\npar le système d'exploitation. Au sens TCP/IP les applications réalisent des\nservices clients/serveurs, par exemple WEB (réseaux sociaux...) ou courrier\nélectronique. Elles définissent généralement des modèles d'identités\npermettant d'établir une politique de contrôle d'accès et des canaux\nsécurisés. Elles accèdent aux ressources du système d'exploitation partagées\npar différentes entités logicielles telles que fichiers, bases de données,\nbibliothèques réseaux ou cryptographiques. Le WEB utilise typiquement un\nmécanisme d'authentification multimodale, certificat et protocole TLS côté\nserveur et HTTP et mot de passe côté client.\nMême si l'on peut concevoir des applications gérant intégralement leur\nsécurité, le maintien d'un secret incassable (non extractible) dans un logiciel\nreste en 2021 sans solution éprouvée; les tentatives infructueuses de\ndéveloppement des techniques WBC (White Box Cryptography) en sont une\nillustration.\nSécurité des protocoles de communication et des réseaux\nLes piles réseau supportent des protocoles de sécurité par exemple\nIPSEC, SSH pour des couches TCP/UDP/IP ou IEEE 802.11i, IEEE 802.1x,\nRADIUS, PPTP pour les infrastructures LAN ou WLAN. Des procédures\ncryptographiques associées fréquemment à des preuves de protocole\nréalisent la confidentialité et l'intégrité des informations transportées. Les\ncouches réseau s'appuient classiquement sur des ressources gérées par le\nsystème d'exploitation, telles que des bibliothèques cryptographiques ou des\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "existe de nombreux systèmes d'exploitation, importés de l'informatique", "section_path": ["existe de nombreux systèmes d'exploitation, importés de l'informatique"], "page": 49, "content": "49\npilotes de circuit de communication. Elles offrent une surface d'attaque au\nniveau MAC ou TCP/IP, mais dont les défauts sont corrigés au fil du temps\nen particulier grâce à une standardisation d'usage des piles logicielles\nréseau. Des systèmes d'exploitation tels que Windows ou Android\nsupportent une politique d'accès à ces ressources selon une granularité plus\nou moins fine, sous forme de firewall d'applications ou d'autorisations. La\ngestion des identités et le confinement des secrets cryptographiques associés,\nsont les piliers sécuritaires de l'établissement d'échanges sécurisés. Les\narchitectures réseaux réalisent également des concepts d'isolation physique\net de cloisonnement, basés sur des nœuds intégrant des fonctions de\nfirewall, de routage ou d'analyse de trafic (Deep Packet Inspection, DPI)\nSécurité du système d'exploitation\nLe système d'exploitation organise l'isolation des processus et des\ndonnées, par exemple à l'aide de mécanismes sandbox, et grâce à la définition\nd'une politique de contrôle d'accès aux fichiers DAC (Discretionary Access\nControl), MAC (Mandatory Access Control) mis en œuvre par SELinux\n(Security Enhanced Linux), ou RBAC (Role Base Access Control) utilisé par\nWindows et Unix. L'intégrité du système d'exploitation, c'est à dire la\nrésistance à une modification non souhaitée de son code, typiquement\nchargé en mémoire au démarrage du système (boot) est un problème\ncritique. Il est partiellement solutionné avec des technologies dites de Secure\nBoot, basées sur des puces électroniques TPM (Trusted Platform Module). La\nréalisation des politiques d'accès s'appuie sur un système d'identité basé sur\ndes tuples login/password ou certificat/clé-privé. La protection des\ndonnées stockées par des mémoires secondaires (disques, flash...) implique\nla définition de système de gestion de fichiers chiffré dont la clé maitre est\nprotégée par un mot de passe (typiquement celui de l'administrateur de la\nmachine). Le stockage sécurisé d'un mot de passe est vulnérable à des\nattaques par force brute. De manière générale le contenu des mémoires\nprimaires (SRAM, DRAM...) est en clair et peut stocker des informations\nsensibles (mots de passe...) collectées par divers procédés.\nSécurité Hardware\nLe hardware classique s'appuie sur des portes logiques CMOS, des bus\nd'interconnexion, et implicitement sur des lois physiques conformes aux\néquations de Maxwell, qui sont sensibles à des attaques par canaux cachés\n(SPA, DPA...). Dans ces conditions le stockage de secrets (Key Caching) est\ntrès difficile. Des circuits électroniques équipés de contre mesures physiques\net logiques (TPM, carte à puce, Secure Element, Secure MCU...) sont de plus\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Heuristiques de défense: placebo, vaccin, défense immunitaire", "section_path": ["Heuristiques de défense: placebo, vaccin, défense immunitaire"], "page": 50, "content": "50\nen plus présents dans les systèmes informatiques, par exemple pour la\nrestitution d'une clé maître de chiffrement de fichiers, liée à un mot de passe.\nLe confinement dans un espace sûr (tamper resistant) évite/limite les attaques\npar force brute (grâce à l'absence de vecteurs d'attaque, par exemple\nempreinte du mot de passe), il impose également un accès physique à la\npuce de sécurité, et peut impliquer des temps d'accès \"importants\" qui\nrendent inefficaces les attaques force brute. De surcroit le blocage\nfonctionnel de la puce au terme d'un nombre fini de présentation du mot de\npasse (PIN code) peut entrainer la non fonctionnalité permanente de la plate\nforme informatique.\nQuelques paradigmes de sécurité\nClassification des types d’attaques\nOn peut classer42 les attaquants d’un système en trois catégories:\n- Classe I - (clever outsiders):. L’attaque accidentelle.\nUn utilisateur constate de manière fortuite un défaut du\nsystème.\n- Classe II - (knowledgeable insiders). L’attaque\nindividuelle ou par de petites communautés (hackers),\nmais avec des moyens limités. L’attaquant réalise un\ninvestissement modeste, mais espère un gain financier ou de notoriété.\n- Classe III - (funded organisations). L’attaque par des organisations\n(Etats, …) disposant de moyens importants. La logique financière n’est pas\nforcément un but.\nHeuristiques de défense: placebo, vaccin, défense immunitaire\n- Le placebo. Une défense utopique mais parfois efficace, est\nutilisée pour parer une attaque inconnue. Par exemple la\nsaignée, l’emploi hasardeux d’antibiotique ou de vaccin.\n- Le vaccin. Une réponse connue et efficace à une attaque\nidentifiée.\n42 DG Abraham, GM Dolan, GP Double, JV Stevens, “Transaction Security\nSystem\", in IBM Systems Journal v 30 no 2 (1991) pp 206 229\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Une Méthodologie de Cyber Attaque: Empreinte, Collecte, Inventaire", "section_path": ["Une Méthodologie de Cyber Attaque: Empreinte, Collecte, Inventaire"], "page": 51, "content": "51\n- La défense immunitaire. Une réponse efficace, est\nspontanément générée, pour lutter contre une attaque\ninconnue. La légende d’Hans Brinker est une illustration de\nce principe.\nFacteurs de Vulnérabilité: Complexité, Extensibilité, Connectivité\nTrois facteurs43 (ou Trinité) amplifient les failles des systèmes\ninformatiques modernes,\n- La complexité. Les logiciels sont complexes, les\ndéveloppeurs ne maîtrisent pas les bugs et les\ncomportements non désirés.\n- L’extensibilité. La configuration d’une plateforme\ninformatique se modifie tout au long de sa durée de vie.\n- La connectivité. Les vulnérabilités des logiciels sont exploitables à\ndistance.\nUne Méthodologie de Cyber Attaque: Empreinte, Collecte, Inventaire\nDans les différentes éditions du best seller44 \"Hacking Exposed\" les auteurs\ndistinguent les trois phases suivantes pour la préparation d'une cyber\nattaque:\n- Le footprinting, c'est à dire la collecte d'informations publiques sur les\ncomposants du système, via internet ou des services tels que WHOIS, DNS\nou TRACEROUTE. Dans cette première phase le but est d'identifier les\nserveurs, leurs adresses IP, la structure du réseau, mais aussi les sites\ngéographiques.\n- Le scanning réalisant la collecte d'informations relatives aux systèmes\nd'exploitation, et aux ports TCP et UDP ouverts.\n- L'inventaire (enumeration) consiste à obtenir des informations précises\nsur les services disponibles et leur version, collectées à l'aide de sessions\nactives.\n43 S. Ravi, A. Raghunathan, P. Kocher, and S. Hattangady, \"Security in\nEmbedded Systems: Design Challenges\", 2004.\n44 \"Hacking Exposed\", Stuart McClure, Joel Scambray, George Kurtz, Mac graw\nHill\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Authentification", "section_path": ["Authentification"], "page": 52, "content": "52\nSystèmes Embarqués\nLes attaques sur les environnements SCADA, CAN, ou de manière plus\ngénérale sur les objets connectés, mettent en évidence les trois principes de\nsécurité suivants :\n- Communications Sécurisées (intégrité, chiffrement...), avec mutuelle\nauthentification forte. Cela implique la disponibilité de clés symétriques ou\nasymétriques, et la définition d'un système d'identité (basé sur des numéros\nde série ou des certificats par exemple)\n- Stockage Sécurisé, par exemple pour les secrets nécessaires aux\ncommunications, mais plus généralement pour des informations sensibles.\n- Intégrité des Nœuds, mécanismes d'isolation logicielle (par exemple\nmulti processeurs pour la résistance aux malwares, SandBox pour l'intégrité\ndu système d'exploitation), mise à jour/chargement de logiciels sécurisée\n(signature des logiciels), prévention détection des intrusions et\ncomportements suspects, prévention des attaques par rebond.\nPrincipes de sécurité.\nClassiquement la sécurité s’appuie sur cinq concepts de base,\nl'identification, l'authentification, la confidentialité, l'intégrité, et la non\nrépudiation. La disponibilité est également importante.\nIdentification\nL’identification (identity). L’utilisateur d’un système ou de ressources\ndiverses possède une identité (une sorte de clé primaire d’une base de\ndonnées) qui détermine ses lettres de crédits (credential) et ses autorisations\nd’usage. Cette dernière peut être déclinée de multiples manières, compte\nutilisateur (login) d’un système d’exploitation ou techniques biométriques\nempreinte digitale, empreinte vocale, schéma rétinien…\nAuthentification\nL’authentification (authentication). Cette opération consiste à faire la\npreuve de son identité. Par exemple on peut utiliser un mot de passe, ou une\nméthode de défi basée sur une fonction cryptographique et un secret\npartagé. L’authentification est simple ou mutuelle selon les contraintes de\nl’environnement.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Au sujet de la confiance", "section_path": ["Au sujet de la confiance"], "page": 53, "content": "53\nConfidentialité\nLa confidentialité (privacy). C’est la garantie que les données échangées\nne sont compréhensibles que pour les deux entités qui partagent un même\nsecret souvent appelé association de sécurité (SA). Cette propriété implique la\nmise en œuvre d’algorithmes de chiffrement soit en mode flux (octet par\noctet, comme par exemple dans RC4, AES-CTR) soit en mode bloc (par\nexemple une série de 8 octets dans le cas du DES, 16 octets pour l'AES).\nIntégrité\nL’intégrité des données (MAC, Message AuthentiCation). Le chiffrement\névite les écoutes indiscrètes, mais il ne protège pas contre la modification des\ninformations par un intervenant mal intentionné. Des fonctions à sens\nunique (encore dénommées empreintes) telles que MD5 (16 octets) ou SHA1\n(20 octets), SHA2, SHA3 réalisent ce service. Le MAC peut être associé à une\nclé secrète, telle la procédure HMAC(Clé, Message), Keyed-Hashing for\nMessage AuthentiCation. Le chiffrement et l'intégrité peuvent être combinés\ndans un seul algorithme AEAD (Authenticated Encryption with Associated\nData), par exemple AES-CCM, AES-GCM.\nNon-répudiation\nLa non-répudiation. Elle consiste à prouver l’origine des données.\nGénéralement cette opération utilise une signature asymétrique en chiffrant\nl’empreinte du message avec la clé privée de son auteur (par exemple\nRSA(Empreinte(Message))).\nDisponibilité\nOn cite fréquemment un sixième attribut relatif à aux notions de sûreté\nde fonctionnement, disponibilité, et résilience du système.\nAu sujet de la confiance\nRemarquons également que la sécurité implique le partage de confiance\nentre les différents acteurs de la chaîne. Pour partager un secret il faut avoir\nconfiance dans les capacités des parties concernées à ne pas le divulguer.\nAinsi les infrastructures à clés publiques (PKI) supposent que l’on fasse\nconfiance aux entités qui produisent les clés privées, et les signatures des\ncertificats.\nLa confiance est une relation sans propriétés particulières.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité des Réseaux", "section_path": ["Sécurité des Réseaux"], "page": 54, "content": "54\nRéflexivité, ai-je confiance en moi-même (pas dans tous domaines).\nSymétrie, je fais confiance au pilote de l’avion ou au chirurgien, la\nréciproque n’est pas forcément vraie.\nTransitivité, j’ai confiance dans le président, le président a confiance\nen la présidente, je n’ai pas obligatoirement confiance dans la présidente.\nLes infrastructures PKI supposent une transitivité de la relation de\nconfiance. Le client du réseau et un serveur d’authentification partagent une\nmême autorité de certification (CA), qui crée une classe de confiance basée\nsur une relation R (R signifiant= «fait confiance à»).\n(Client R CA) ET (Serveur R CA) => (Client R Serveur)\nSécurité des Réseaux\nUn réseau assure le transport des messages échangés entre deux\napplications distantes. Dans le modèle OSI les services déployés par le\nréseau sont classés en sept couches, physique, données, réseau, transport,\nsession, présentation et application. Le modèle classique des réseaux TCP/IP\nne comporte que 5 couches, physique (PMD+PHY), données (MAC+LLC),\nréseau (IP), transport (UDP+TCP) et applications.\nDans cette section nous ne prendrons en compte que ce dernier modèle,\nqui est aujourd’hui le standard de facto pour l’échange d’informations\nnumériques.\nApplication Application\nUDP/TCP UDP/TCP\nIP IP IP IP\nLLC LLC LLC LLC\nMAC MAC MAC MAC\nPHY PHY PHY PHY\nPMD PMD PMD PMD\nDes mécanismes tels que confidentialité ou intégrité des données peuvent\nêtre intégrés à tous les niveaux et sur les différents tronçons (arcs) qui\ncomposent le réseau. La gestion des clés cryptographiques sera par exemple\nréalisée manuellement. L’identification l’authentification la non répudiation\nles autorisations sont des procédures mises en œuvre dans le réseau d’accès\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité au niveau réseau/transport", "section_path": ["Sécurité au niveau réseau/transport"], "page": 55, "content": "55\n(sans fil par exemple), le réseau de transport (IP), le réseau de destination\n(intranet …). De même ces services peuvent également être offerts au niveau\napplicatif.\nAppli\nAppli\n4\n4\n3 3 3 3 3 3\n2 2 2 2 2 2\n1 1 1 1 1 1\nRouteur Routeur\nSchématiquement nous classerons les infrastructures de sécurité des\nréseaux en cinq catégories, dédiés aux couches OSI physique, MAC,\nTCP/IP, application, ou intégré entre transport et application.\nSécurité au niveau physique\nLe chiffrement au niveau physique sur des liaisons point à point. Par\nexemple cryptographie quantique (PMD), saut de fréquences pseudo\naléatoire, ou chiffrement 3xDES du flux octets (une méthode couramment\ndéployée par les banques). Dans ces différentes procédures les clés sont\ndistribuées manuellement.\nSécurité au niveau MAC\nConfidentialité, intégrité de données, signature de trames MAC. C’est la\ntechnique choisie par les réseaux sans fil 802.11. La distribution des clés est\nréalisée dans un plan particulier (décrit par la norme IEEE 802.1x). Dans ce\ncas on introduit la notion de contrôle d’accès au réseau LAN, c’est à dire à la\nporte de communication avec la toile d’araignée mondiale. C’est une notion\njuridique importante, le but est d’interdire le transport des informations à\ndes individus non authentifiés (et donc potentiellement malveillants…).\nSécurité au niveau réseau/transport\nConfidentialité, intégrité de données, signature des paquets IP et/ou\nTCP. C’est typiquement la technologie IPSEC en mode tunnel. Un paquet IP\nchiffré et signé est encapsulé dans un paquet IP non protégé. En effet le\nroutage à travers l’Internet implique l’analyse de l’entête IP, par les\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité au niveau application", "section_path": ["Sécurité au niveau application"], "page": 56, "content": "56\npasserelles traversées. IPSEC crée un tunnel sécurisé entre le réseau d’accès\net le domaine du fournisseur de service. On peut déployer une gestion\nmanuelle des clés ou des protocoles de distribution automatisés tels que\nISAKMP et IKE. La philosophie de ce protocole s’appuie sur la libre\nutilisation du réseau d’accès ce qui n’est pas sans soulever des problèmes\njuridiques. Par exemple des pirates protègent leurs échanges de données, il\nest impossible aux réseaux traversés de détecter leur complicité dans le\ntransport d’informations illégales.\nCouche de Sécurité entre transport et application\nInsertion d’une couche de sécurité additive assurant la protection\nd’application telles que navigateurs WEB ou messageries électroniques. Par\nexemple le protocole SSL/TLS basé sur la cryptographie asymétrique réalise\ncette fonction. Généralement ce dernier conduit une simple authentification\nentre serveur et client. Il utilise un secret partagé (Master Secret) à partir\nduquel on dérive des clés de chiffrements utilisées par l’algorithme négocié\nentre les deux parties. Par exemple dans le cas d’une session entre un\nnavigateur et un serveur bancaire, le client authentifie son service bancaire.\nUne fois le tunnel sécurisé établit le client s’authentifie à l’aide d’un login et\nd’un mot de passe. Il obtient alors une identité temporaire associée à un\nsimple cookie.\nSécurité au niveau application\nGestion de la sécurité par l’application elle-même. Ainsi le protocole S-\nMIME réalise la confidentialité, l’intégrité et la signature des contenus\ncritiques d’un message électronique.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Authentification - Autorisation", "section_path": ["Authentification - Autorisation"], "page": 57, "content": "57\nEléments de Sécurité\nAuthentification - Autorisation\nRESEAU ENTITE B\nENTITE A\nHOSTILE\nR IDT\nA A\nR IDT\nB B\nK = F(R , R , K [IDT ,IDT ]) K , K = G(R ,R , K )\nM A B S, A B C I A B M\nCanal de Transmission Sécurisé\n{M}K HMAC(M, K)\nC I\nLa procédure d’authentification d’une paire d’entités informatique, parfois\ndénommée phase d’autorisation, consiste typiquement à échanger les\nidentités (IDT et IDT ) d’un couple d’interlocuteurs (appelés client/serveur\nA B\nou initiateur/répondeur), deux nombres aléatoires (R , R ) formant un\nA B\nidentifiant unique de la session (RA||RB), puis d’effectuer un calcul\ncryptographique (F, une fonction de type Pseudo Random Function - PRF).\nCe dernier produit, à l’aide d’une valeur secrète (K , un secret à long terme)\nS\nun secret maître (K ), à partir duquel on déduit (à l’aide d’une fonction G,\nM\nde type Key Data Function - KDF) des clés de chiffrement (K ) et d’intégrité\nC\n(K) permettant de créer un canal sécurisé (keying).\nI\nDans un contexte de cryptographie symétrique la clé K est statique et\nS\ndistribuée manuellement; dans un contexte de cryptographie asymétrique la\nclé K sera par exemple générée par A, mais chiffrée par la clé publique (e,n)\nS\nde B ( Ke mod n ), ou bien déduit d’un échange de Diffie-Hellman (K=gxy)\ns s\nLa protection de l’identité est une préoccupation croissante avec l’émergence\ndes technologies sans fil. Il existe divers mécanismes permettant d’obtenir\ncette propriété avec des degrés de confiance différents, par exemple grâce à\nla mise en œuvre de pseudonymes (tel que le TIMSI du GSM), du protocole\nde Diffie-Hellman, ou du chiffrement de certificats à l’aide la clé publique\ndu serveur.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité du canal", "section_path": ["Sécurité du canal"], "page": 58, "content": "58\nSécurité du canal\nUn schéma cryptographique assurant à la fois intégrité et confidentialité\ngarantit la sécurité contre les attaques à chiffrés choisis IND-CCA (Chosen-\nCiphertext Attack). Deux propriétés sont nécessaires :\n- IND-CPA= Chosen Plaintext Attack\n- INT-CTXT= Integrity of CipherTeXT\nEn d’autres termes il faut chiffrer les données et vérifier leur intégrité\navec un MAC (Message Authentification Code). Plusieurs méthodes sont\npossibles pour ces opérations: quel niveau de sécurité peut on espérer45 ?.\nL’algorithme MAC-And-Encrypt, soit E(M) || MAC(M), n’est pas sûr.\nLe MAC du message (M) est calculé avant\nchiffrement, le paquet est la concaténation\ndu MAC et du message chiffré.\nL’algorithme MAC-Then-Encrypt, soit E( M || MAC(M) ) n’est pas\ngénériquement sûr, mais en pratique on peut\nconstruire des schémas sûrs (avec des\npreuves de sécurité), tels que AES-CCM.\nLes versions TLS 1 et 2 utilisent ce schéma, un HMAC est ajouté au\nmessage, avec des octets de padding optionnels, puis l’ensemble est chiffré\nE( M || HMAC(M) || Padding_Bytes). Des attaques telles que Lucky\nThirteen s’appuient sur le fait que les octets de padding ne sont pas pris en\ncompte dans le calcul HMAC.\n45 http://www.di.ens.fr/~fouque/mpri/MAC.pdf\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Sécurité des échanges de Diffie Hellman", "section_path": ["Sécurité des échanges de Diffie Hellman"], "page": 59, "content": "59\nUne ancienne version du keystore Android protégeait les clés\nsymétriques par un procédé MAC-Then-Encrypt tel que:\n- AES-CBC ( MD5(Header || Key) || (Header || Key) )\nL’article46 décrit une attaque qui forge des petites clés, basée sur la\ncoïncidence de taille (16 octets) du calcul MD5 et des blocs AES.\nL’algorithme Encrypt-Then-MAC, soit E(M) || MAC(E(M)) est sûr, si le\nmode de chiffrement est sûr, et que le MAC réalise l’intégrité.\nAprès une série d’attaques liées à l’usage du\nmode cryptographique de chiffrement CBC et de\nl’usage de l’algorithme MAC-Then-Encrypt, le\nprotocole TLS 1.3 a adopté des algorithmes\nAuthenticated Encryption with Associated Data\n(AEAD) tels que AES-CCM, qui utilisent\ngénéralement des CMAC (block-cipher-based\nMAC).\nSécurité des échanges de Diffie Hellman\nConsidérons un échange de Diffie Hellman (DH) dans Z/pZ*, avec p\npremier, soit (gx)y mod p, gx est une clé publique (p ), y une clé privée, et g\nk\nun générateur d’ordre p-1.\nD’après le théorème de Sylow, si l’ordre N d’un groupe se décompose en\nfacteurs premier (qi), N= ∏ qiki, il existe des sous groupes d’ordre qki. La\ndécomposition en facteurs premier de N= p-1 nous montre donc l’existence\nde sous groupes d’ordre qki. De surcroit les sous groupes d’un groupe\ncyclique (monogène) sont cycliques.\nDans Z/pZ* il existe des générateurs d’ordre p-1, mais aussi des\ngénérateurs pour des sous groupes plus petits dont l’ordre divise p-1. Une\nattaque possible dans les échanges DH est de proposer une clé publique p =\nk\ng x utilisant un générateur dont l’ordre d divise p-1 (d | p-1).\nd\n46 Mohamed Sabt, Jacques Traoré, \"Breaking Into the KeyStore: A Practical\nForgery Attack Against Android KeyStore\", ESORICS 2016 .\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaque DH et contre mesure", "section_path": ["Attaque DH et contre mesure"], "page": 60, "content": "60\nComment trouver des générateurs dans Z/pZ*\nIl existe ϕ(p-1) générateurs (ϕ étant le nombre d’Euler), le nombre\nmaximum de générateurs est (p-1)/2, c’est à dire le nombre d’entiers impairs\ninférieurs à p. Si p est de la forme p=1+2n, ϕ(p-1)= ϕ(2n)= 2n-1= (p-1)/2.\nUne méthode consiste à trouver des générateurs g d’ordre qiki (il existe\nki\nϕ(qiki) = (qi-1).qki-1 générateurs d’ordre qiki ) puis d’en réaliser le produit. Il\nexiste ϕ(p-1) générateurs soit ϕ(p-1)= ∏ ϕ(qiki)= ∏ (qi-1).qi(ki-1).\nSafe Prime\nUn Safe Prime p est de la forme p=2q + 1 avec q premier, q est le Sophie\nGermain prime de p. On en déduit p-1 = 2q , et ϕ(p-1)= q-1. Il existe un\ngénérateur d’ordre 2 (p-1, puisque (p-1)2=1 mod p) et q-1 générateurs\nd’ordre q.\nSi p = 7 mod 8 (voir RFC 7919), p est un diviseur du nombre de Mersenne\nMq = 2q−1, on en déduit que 2 est un générateur d’ordre q. Par la suite 2k\navec k є [1, q-1] est un générateur d’ordre q.\nLes générateurs d’ordre p-1 sont obtenus par les produits (p-1) 2k mod p.\nAttaque DH et contre mesure\nConsidérons un groupe d’ordre N= ∏ qiki. H un sous groupe d’ordre q\npremier (q|n), g est un générateur de H d’ordre q= qi; par exemple le plus\nq\ngrand qi.\nSoit d un diviseur de N, g un générateur d’ordre d < q. Par exemple\nd\ndans Z/pZ d | (p-1).\np = g x x є [1, d] une clé publique malicieuse, (g x)d = 1, il existe d secrets\nk d d\npartagés DH = g xy y є [1, q]\nd\np = g x une clé publique bien formée, c’est à dire un générateur de H\nk q\nd’ordre q, (g x)q = 1 il existe q secrets partagés DH.\nq\nLe test p q =1 (implémenté par exemple dans OPENSSL) identifie une clé\nk\npublique bien formée d’ordre q. Une clé publique malicieuse dont l’ordre d\nne divise pas q est détectée par ce test.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Mise à jour des clés cryptographiques", "section_path": ["Mise à jour des clés cryptographiques"], "page": 61, "content": "61\nMise à jour des clés cryptographiques\nClaude Shannon a défini la notion d’entropie de l’information.\nH = - ∑ p(x) log p(x), soit log (n) pour n symboles équiprobables, pour\ni 2 i 2\nn=2p l’entropie est de p bits.\nL’entropie conditionnelle de X sachant Y s’écrit:\nH(X,Y) = - ∑ p(X=x,Y=y) log p(X=x,Y=y)\n2\nH(X,Y) = H(X) + H(Y|X), H(Y|X)= H(X,Y) - H(X)\nUn système cryptographique parfait au sens de Shannon est tel que:\nH(M|C) = H(M), M le message en clair et C le message chiffré.\nPar exemple une clé K constituée par une suite d’octets aléatoires\nR ,R ,….,R réalise un système cryptographique parfait (Ci = R exor M, M =\n1 2 i i i i\nRi exor C), c’est le code de Vernam.\ni\nH(C)= p\np(X=M,Y=C) = p(X=M) x 1/n = 1/n2\ni j i\nD’où H(M,C) = 2p, H(M) = H(C)\nEn particulier lorsque tous les messages en clair sont équiprobables la\ntaille de la clé doit être au moins aussi grande que la taille des messages en\nclair. Un algorithme de chiffrement utilisant une clé de taille finie, cette\ndernière doit être modifiée de temps à autre.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Identité et Organisations", "section_path": ["Identité et Organisations"], "page": 62, "content": "62\nIdentité et Organisations\nL’identité détermine les autorisations et/ou la localisation d’une\npersonne, d’un objet (parfois intelligent), ou des deux, relativement à une\norganisation (étatique, privée…). L’authentification est la procédure qui\nconsiste à faire la preuve d’une identité. On peut utiliser divers moyens :\n- Ce qui je suis, méthodes biométriques, éventuellement multi modales\n(passeport électronique…)\n- Ce que je connais, mot de passe, ….\n- Ce que je possède, carte à puce, jeton USB…\nVoici quelques exemples d’organisations gérant des d’identités :\n-Les états (identité des citoyens et des visiteurs). Les identités utilisent par\nexemple la biométrie (programme US-Visit), les passeports électroniques, les\ncartes d’identité munies de puces (CNIE).\n- Le WEB (Applications WEB). Il existe de multiples infrastructures\nd’identités telles que, Single Sign On (SSO), Microsoft Passport, Liberty\nAlliance, OPENID, FIDO,…\n- L’industrie (localisation, inventaire…). L’identité des objets est associée à\ndes étiquettes (code barre, code 2D) ou des RFIDs.\n- Les services informatiques gèrent des ordinateurs personnels. L’identité\nd’une machine est par exemple assurée par un Trusted Platform Module\n(TPM).\n- Les réseaux bancaires réalisent des opérations de paiement associées à des\ncartes BO’ ou EMV.\n- Les réseaux de communication réalisent des échanges de données, et\nmettent en œuvre différentes identités : couple login mot de passe, carte SIM\nou USIM, Wi-Fi et EAP-ID, jetons divers (tels que RSA SecurID, FIDO, Titan\nKey…)\nGoogle Titan Key\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Mécanismes symétriques: mot de passe, pre-shared key, provisionning", "section_path": ["Mécanismes symétriques: mot de passe, pre-shared key, provisionning"], "page": 63, "content": "63\nTaxonomie des méthodes d’authentification\nNous classons les méthodes d’authentification en trois catégories,\nsymétriques (secrets partagés), asymétriques (basées sur RSA ou ECC en\nrègle générale) et tunnels.\nMécanismes symétriques: mot de passe, pre-shared key, provisionning\nNous divisons les méthodes symétriques en trois classes\n- Les mots de passe. Un mot de passe est une suite de caractères qui peut\nêtre facilement mémorisée par un être humain. Il ne s’agit pas d’un nombre\naléatoire mais au contraire d’une concaténation de mots, de chiffres et de\nsignes. De tels secrets peuvent être devinés à l’aide d’une attaque par\ndictionnaire, c’est à dire un programme utilisant une base de données pour\nla génération de ces valeurs. Ainsi les méthodes EAP-MSCHAPv2 ou LEAP\nreposent sur la clé NT, c’est à dire l’empreinte MD4 (soit 16 octets) d’un mot\nde passe.\nDans les anciens systèmes UNIX la liste des empreintes des mots de\npasse est stockée dans le ficher /etc/passwd. Le fichier /etc/shadow lisible\nuniquement en mode root est aujourd’hui préféré. Un mot de passe est par\nexemple une chaîne d’au plus 8 caractères ASCII, convertie en une clé DES\nde 56 bits (8 x 7bits). La fonction crypt(key, salt) réalise dans ce cas 25\nchiffrements DES consécutifs (avec une valeur initiale IV=0), dont chacun\ncomporte une permutation choisie parmi 4096 possible (soit 12 bits, c’est le\nparamètre salt, deux caractères choisis parmi 64 valeurs possibles a-z A-Z 0-9\n. /). D’autres algorithmes de génération d’empreinte sont supportés, tels que\nla fonction MD5.\nIV=0\nDans l’univers Microsoft la sécurité d’un ordinateur personnel est\nfortement corrélée au mot de passe de son utilisateur. Ce dernier n’est jamais\nstocké en clair dans la mémoire de la machine. A partir d’un mot de passe\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Mécanismes symétriques: mot de passe, pre-shared key, provisionning", "section_path": ["Mécanismes symétriques: mot de passe, pre-shared key, provisionning"], "page": 64, "content": "64\non calcule une empreinte MD4 de 16 octets, mémorisée par le système hôte.\nCette valeur, parfois nommée clé NT ou NtPasswordHash est complétée par\ncinq octets nuls. On obtient ainsi 21 octets interprétés comme une suite de\ntrois clés DES (de 56 bits chacune).\nMD4 Mot de Passe\nrandom 8 octets\nClé NT\nDES (r), DES (r), DES (r)\n3x7 = 16 octets + 5 nuls Key1 Key2 Key3\n= {Key1, Key2, Key3}\nLa méthode MSCHAPv1 est une authentification simple, le serveur\nd’authentification produit un nombre aléatoire de 8 octets, l’authentifié\nutilise ses trois clés DES pour chiffrer cet aléa, ce qui génère une réponse de\n24 octets.\nMSCHAPv2 est une extension du protocole précédent, le serveur\nd’authentification délivre un nombre aléatoire de 16 octets\n(AuthenticatorChallenge), le client calcule un nombre 8 octets à partir de cette\nvaleur, d’un aléa (PeerChallenge) qu’il génère et du nom de l’utilisateur\n(login). Ce paramètre est chiffré de manière analogue à MSCHAPv1 par la\nclé NT et l’on obtient une valeur de 21 octets. Dans une plateforme Microsoft\nun annuaire stocke le nom des utilisateurs et leur clé NT.\nPeerChallenge\nAuthenticatorChallenge\nF (SHA1)\nr= 8 octets DES1(r), DES2(r), DES3(r)\nSous Windows le SAM (Security Account Manager) est la base de données\nqui contient les informations sur les comptes utilisateurs (login, mot de\npasse). L'image du SAM est stockée dans le fichier\nC:\\Windows\\System32\\config et également dans la base de registre\nHKEY_LOCAL_MACHINE\\SAM. Cependant ces informations ne sont pas\naccessibles au runtime. On obtient un copie du SAM en démarrant la\nmachine sous un autre système d'exploitation (typiquement linux), mais\naussi à l'aide d'utilitaires de hacking tels que fgdump.exe (exécuté en mode\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Les tunnels", "section_path": ["Les tunnels"], "page": 65, "content": "65\nadministrateur). Selon47 dans la méthode LM Hash le mot de passe d'un\ncompte utilisateur est complété à 14 octets à l'aide d'octets nuls, puis\ntransformé en une deux clés DES distinctes réalisant le chiffrement de la\nvaleur ASCII KGS!@#$% (soit 2x8 octets). La procédure NTLM Hash stocke\nl'image MD4 (16 octets) du mot de passe.\nDes programmes tels que CAIN ou Windows Password Recovery réalisent\ndes attaques par force brute, dictionnaire ou rainbow tables.\n- Les secrets partagés (PSK, Pre-Shared-Key). Il s’agit en fait d’un nombre\naléatoire, dont la taille est l’ordre de 128 à 160 bits. Un cerveau humain\néprouve beaucoup de difficultés à mémoriser ces informations. Le stockage\nsécurisé du secret est réalisé par exemple par le système d’exploitation d’un\nordinateur personnel ou par une carte à puce.\n- Le mode provisioning. Dans les réseaux GSM, 3G, 4G, 5G une base de\ndonnées centralisée (Host Location Register) gère les comptes utilisateurs, en\nparticulier leur PSK. Afin d’éviter des interrogations fréquentes les\nméthodes d’authentification (A3/A8, Milenage) sont conçues de telle\nmanière que le site central puisse produire des vecteurs d’authentification\n(triplets GSM ou quadruplets UMTS), réutilisables par des agents de\nconfiance (tels que les Visitor Location Register par exemple).\nMécanismes Asymétriques\nCes procédures sont basées sur des algorithmes tels que ECC, RSA ou\nDiffie-Hellman. Le protocole SSL/TLS est généralement utilisé pour le\ntransport de ces échanges.\nLes tunnels\nAinsi que nous l’avons souligné précédemment les méthodes\nd’authentification basées sur des mots de passe, sont sujettes à des attaques\npar dictionnaire. Ainsi le protocole MSCHAP assure une protection jugée\nraisonnable dans des environnements sûrs (par exemple des intranets ou des\nconnexions par modem), mais n’est plus adapté lors d’une mise en œuvre\ndans un milieu hostile, tel que IP sans fil, abritant potentiellement de\nnombreuses oreilles électroniques indiscrètes.\nLes tunnels, s’appuyant fréquemment sur la technologie SSL/TLS,\nprotègent un dialogue d’authentification grâce au chiffrement des données\néchangées. Il existe aujourd’hui de multiples standards devenus nécessaires,\n47 https://technet.microsoft.com/en-us/library/cc875839.aspx, \"Selecting Secure\nPasswords\"\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Les faiblesses du protocole IP", "section_path": ["Les faiblesses du protocole IP"], "page": 66, "content": "66\nen raison des nombreux logiciels disponibles sur le WEB qui cassent les\nprotocoles à base de mot de passe.\nLes faiblesses du protocole IP\nPar nature un réseau est sensible au déni de service, au niveau physique\n(brouillage divers…) ou logique (destruction/modification des paquets ou\ndes trames).\nLe protocole ARP (Address Resolution Protocol) réalise une correspondance\nentre une adresse MAC et une adresse IP. Dans l’attaque dite ARP spoofing\nl’attaquant forge une trame de réponse (ARP.response) erronée. Il en résulte\nun détournement du trafic IP.\nUn paquet IP comporte typiquement un en tête de 20 octets démuni\nd’attributs cryptographiques de sécurité. La confidentialité et l’intégrité des\ndonnées transportées ne sont donc pas assurées.\nLe mécanisme de segmentation est difficilement analysable par les pare-\nfeu. En effet, seul le premier segment IP contient l’entête du protocole\nsupérieur transporté, par exemple TCP ou UDP. De même le réassemblage\npeut entraîner un problème de déni de service pour la machine de réception\n(la taille maximale d’un paquet IP est de 65535 octets et le temps de\nréception des fragments est indéterminé).\nLa correspondance adresse IP nom de machine est typiquement réalisée\npar le protocole DNS qui n’offre aucun service d’authentification ou\nd’intégrité.\nLorsqu’un pare-feu autorise les paquets ICMP, il s’expose à de possibles\ncanaux cachés, utilisés par exemple pour dialoguer avec des chevaux de\nTroie, dont les informations sont transportées par des paquets\nICMP.response.\nLe protocole TCP ne propose aucune authentification du serveur lors de\nl’ouverture d’une session (paquets SYN et ACK+SYN).\nLe SYN-Flooding est une technique d’attaque de déni de service qui\nconsiste à générer en grand nombre de paquets TCP-SYN.\nL’analyse des ports TCP (en mode serveur) ouverts d’un nœud IP (port\nscan) repose sur la possibilité de forger librement des paquets TCP-SYN.\nIl est possible de mettre fin à une session TCP à l’aide de paquets TCP-\nRESET. Connaissant l’adresse IP du client en supposant une fenêtre de\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "IPSEC", "section_path": ["IPSEC"], "page": 67, "content": "67\nréception (RWIN) de 214 et une plage de ports éphémères de 210 le nombre de\npaquets nécessaire est de l’ordre de 232/214*210 = 228.\nDe nombreux protocoles (PPP, POP, FTP,…) mettent en œuvre des mots\nde passe transmis en clair sur le réseau. Certaines messageries ne supportent\npas un transport sécurisé par SSL/TLS.\nGlobalement le modèle Internet présente une insécurité quasi globale,\nnotamment au niveau de la messagerie…., et pourtant il fonctionne\nquotidiennement.\nLes solutions sécurisées IP classiques: VPN, TLS, Kerberos, SSH\nIPSEC\nIPSEC assure l’intégrité, l’authentification et la confidentialité des charges\ntransportées par le protocole IP. Les ressources cryptographiques sont\ndéduite d’une association de sécurité (SA) basée sur un secret partagé entre\nles deux entités de la session sécurisée IP. La difficulté de déploiement du\nprotocole IPSEC est liée au mécanisme d’établissement d’un SA, à l’aide du\nprotocole IKE (Internet Key exchange, qui réalise un premier tunnel sécurisé à\nl’aide d’un protocole de Diffie-Hellman). Bien que l’usage de certificats soit\npossible, c’est généralement une clé pré définie (PreShareKey) qui permet\nl’authentification des deux extrémités de la communication.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "IPSEC", "section_path": ["IPSEC"], "page": 68, "content": "68\nInitiator Responder\n----------- ----------- Echange\nHDR, SA --> Chiffré\n<-- HDR, SA\nHDR, KE, Ni -->\n<-- HDR, KE, Nr\nHDR*, IDii, [ CERT, ] SIG_I -->\n<-- HDR*, IDir, [ CERT, ] SIG_R\nFor pre-shared keys:\nSKEYID = prf(pre-shared-key, Ni_b | Nr_b)\nThe result of either Main Mode or Aggressive Mode is three groups of\nauthenticated keying material:\nSKEYID_d = prf(SKEYID, g^xy | CKY-I | CKY-R | 0)\nSKEYID_a = prf(SKEYID, SKEYID_d | g^xy | CKY-I | CKY-R | 1)\nSKEYID_e = prf(SKEYID, SKEYID_a | g^xy | CKY-I | CKY-R | 2)\nand agreed upon policy to protect further communications. The values\nof 0, 1, and 2 above are represented by a single octet. The key used\nfor encryption is derived from SKEYID_e in an algorithm-specific\nmanner.\nTo authenticate either exchange the initiator of the protocol\ngenerates HASH_I(SIG_I) and the responder generates HASH_R(SIG_R)\nwhere:\nHASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b )\nHASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b )\nSAi_b is the entire body of the SA payload (minus the ISAKMP generic header), all\nproposals and all transforms offered by the Initiator.\nCKY-I and CKY-R are the Initiator's cookie and the Responder's cookie, respectively,\nfrom the ISAKMP header.\ng^xi and g^xr are the Diffie-Hellman public values of the initiator and responder\nrespectively.\nProtection d’identité et calcul de clé dans le protocole IKE, en phase 1,\npreshared key main mode.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "TLS/SSL", "section_path": ["TLS/SSL"], "page": 69, "content": "69\nMode Transport et Tunnel dans le protocole ESP, IPSEC\nEn tête du protocole ESP.\nTLS/SSL\nLe protocole SSL/TLS délivre des services analogues à IPSEC, mais au\nniveau applicatif. Cependant le mécanisme d’établissement du secret\npartagé maître repose généralement sur des clés RSA et des certificats X509.\nDe manière classique le certificat du serveur est vérifié relativement à une\nchaîne de confiance (suite de certificats délivrés à partir d’un certificat\nracine). Côté client les points critiques sont l’installation d’un nouveau\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "TLS/SSL", "section_path": ["TLS/SSL"], "page": 70, "content": "70\ncertificat d’une autorité de certification, et la vérification des certificats\nserveurs.\nClient\nServer\nClient hello (ClientRandom)\nServer Hello (ServerRandom)\nServer CA\nCertificate KPubS KPubCA\n[CertificateRequest]\nServerHelloDone\nClient\n[Certificate] KPubC\nClientKeyExchange {PreMasterSecret}K\nPubS\n[CertificateVerify] {MessagesDigest} K\nPrivC\nChangeCipherSpec\n(Encrypted+Signed MessagesDigest) Finished\nChangeCipherSpec\n(Encrypted+Signed MessagesDigest) Finished\nMasterSecret=\nPRF(PreMasterSecret,\"master secret\", ClientRandom|ServerRandom)\nClés = PRF(MasterSecret, Etiquette,ServerRandom|ClientRandom)\nOuverture d’une session TLS 1.0, 1.1, 1.2\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "TLS1.3", "section_path": ["TLS1.3"], "page": 71, "content": "71\nTLS1.3\nTLS 1.3 gère trois modes d'échange de clés:\n- (EC)DHE: Echange Diffie-Hellman (DH) dans des corps finis ou des\ncourbes elliptiques\n- Pre-Shared-Key (PSK) uniquement: clé pré-partagée sans échange DH\n- Pre-Shared-Key (PSK) avec (EC)DHE: clé pré-partagée et échange DH\nIl existe deux alternatives pour authentifier les serveurs:\n- L’usage d’un certificat (message Certificate) serveur et d’une clé privée\nassociée, qui calcule une signature (message CertificateVerify) permettant\nd’authentifier l’échange DH.\n_ La mise œuvre d’un secret pré-partagé (PSK) utilisé dans les\nprocédures de calculs des clés.\nLes deux messages en clair sont ClientHello et ServerHello, chacun\ncomportant une clé publique (aG, bG) permettant de calculer un secret DH\nabG (en notation additive). Un premier canal sécurisé est établi pour les\nmessages handshake. Un deuxième canal est mis en place pour les données\napplicatives.\nTLS1.3 utilise des canaux sécurisés de type Authenticated Encryption with\nAssociated Data (AEAD), tels que AES-CCM ou AES-CGM. L’entête du\npaquet record en clair (soit 5 octets) constitue les données associées\nauthentifiées, la charge est chiffrée et authentifiée.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "TLS1.3", "section_path": ["TLS1.3"], "page": 72, "content": "72\nPSK -> HKDF-Extract = Early Secret\n|\n+-----> Derive-Secret(., \"ext binder\" | \"res binder\", \"\")\n| = binder_key\n|\n+-----> Derive-Secret(., \"c e traffic\", ClientHello)\n| = client_early_traffic_secret\n|\n+-----> Derive-Secret(., \"e exp master\", ClientHello)\n| = early_exporter_master_secret\nv\nDerive-Secret(., \"derived\", \"\")\n|\nv\n(EC)DHE -> HKDF-Extract = Handshake Secret\n|\n+-----> Derive-Secret(., \"c hs traffic\",\n| ClientHello...ServerHello)\n| = client_handshake_traffic_secret\n|\n+-----> Derive-Secret(., \"s hs traffic\",\n| ClientHello...ServerHello)\n| = server_handshake_traffic_secret\nv\nDerive-Secret(., \"derived\", \"\")\n|\nv\n0 -> HKDF-Extract = Master Secret\n|\n+-----> Derive-Secret(., \"c ap traffic\",\n| ClientHello...server Finished)\n| =\nclient_application_traffic_secret_0\n|\n+-----> Derive-Secret(., \"s ap traffic\",\n| ClientHello...server Finished)\n| =\nserver _application_traffic_secret_0\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Kerberos", "section_path": ["Kerberos"], "page": 73, "content": "73\nAu sujet du Phishing\nL’apparition des attaques dites de Phishing, dont le but est de collecter\ndes numéros de carte bancaire ou des informations permettant d’accéder à\ndes comptes bancaires résulte de deux faiblesses clés de l’Internet:\n1) La difficulté à authentifier au niveau TCP/IP les serveurs distants\n(DNS non sécurisé, paquet IP non authentifié, détournement de session\nTCP…), et\n2) La difficulté de la vérification des certificats serveurs.\nKerberos\nKerberos est un protocole développé par le MIT (Massachusetts Institute of\nTechnology) dont les deux versions majeures sont v4 et v5. La version 4\ns’appuie sur l’algorithme cryptographique DES; La version 5 supporte\n3xDES et AES. C’est un standard IETF, RFC 1510 (kerberos v5, 1993).\nKerberos utilise un paradigme à base de tickets établissant une preuve\nd’identité entre deux entités (un utilisateur et un service).\nLe système comporte trois classes de composants, le client, le KDC (Key\nDistribution Center), et des serveurs d’applications. Le KDC regroupe un\nserveur d’authentification (AS), un serveur de tickets (TGS, Ticket Granting\nService) et une base de données clients. Les messages sont codés selon la\nsyntaxe ASN.1\nLe Realm est un nom de domaine lié (example.com) à une autorité\nd’authentification. Un utilisateur appartient à un domaine lorsqu’ il partage\nun mot de passe ou une clé cryptographique avec ce dernier.\nLe Principal est la clé d’identification dans la base de données client.\nLe Ticket est une donnée délivrée par le serveur d’authentification qui\ncomprend:\n- Une zone d’information chiffrée avec la clé de l’utilisateur, comportant\nune date de validité du ticket et une clé de session du service.\n- Une zone d’information chiffrée avec la clé du service, incluant une date\nde validité et une clé de session du service;\nLa base de données du KDC stocke toutes les informations associées à un\nprincipal (mot de passe, clé, etc…).\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "PPTP-EAP", "section_path": ["PPTP-EAP"], "page": 74, "content": "74\nLe serveur d’authentification réalise l’authentification d’un utilisateur à\nl’aide de son mot de passe; il délivre un ticket d’authentification, Ticket\nGranting Ticket, ou TGT, identifié par un principal. Le Ticket Granting Server\n(TGS) génère des tickets de service pour un utilisateur authentifié, c’est-à-\ndire muni d’un TGT.\nLa clé de session (Session Key) est dans le cas d’un utilisateur du KDC une\nclé cryptographique (DES, 3xDES, AES) déduite de son mot de passe; et\ndans le cas d’un service elle est générée par le KDC.\nUn authenticator est une structure d’authentification comportant l’identité\nde l’utilisateur et une date chiffrée avec la clé de session service. Un\nauthenticator lié à un ticket de service évite la duplication illicite de ticket. La\nprésence d’un authenticator «frais» prouve la connaissance de la clé de\nsession de service.\nPPTP-EAP\nLe protocole PPTP (Point To Point Tunneling Protocol) est d’origine\nMicrosoft, il est détaillé par la RFC 2637. Une trame PPP (Point To Point\nProtocol) est transportée sur IP à l’aide du protocole GRE (Generic Routing\nEncapsulation) développé par CISCO. Le protocole PPP utilise par exemple\nEAP (Extensible Authentication Protocol) pour l’authentification la génération\nde clés de chiffrement. La double procédure EAP PEAP/MSCHAPv2 soit\nl’établissement d’un premier tunnel TLS, puis un échange de messages selon\nMSCHAPv2 protégeant un mot de passe est largement utilisée dans ce\ncontexte.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "SSH", "section_path": ["SSH"], "page": 75, "content": "75\nSSH\nLa première version de SSH (SSH-1) fut conçue par Tatu Ylönen, à Espoo,\nen Finlande en 1995. La version suivante a été nommée SSH-2. Le groupe de\nrecherche de l'IETF secsh a défini en janvier 2006 le standard Internet SSH-2,\npar un jeu de RFCs\nRFC 4251, Secure Shell (SSH) Protocol Architecture\nRFC 4253, The Secure Shell (SSH) Transport Layer Protocol\nRFC 4252, The Secure Shell (SSH) Authentication Protocol\nRFC 4254, The Secure Shell (SSH) Connection Protocol\nLe document \"Protocol Architecture\" (RFC 4251) décrit les différents\néléments de SSH:\n- Les messages SSH sont transportés par des paquets TLP (Transport Layer\nProtocol). TLP réalise l’authentification du serveur, la confidentialité et\nl’intégrité des messages SSH. Le calcul des clés est basé sur un échange\nDiffie-Hellman, dont les paramètres sont certifiés par une signature DSA\ngénéré par le serveur.\n- Le bloc User Authentication Protocol, est en charge de l’authentification\ndu client, généralement grâce à un couple login/password, mais il est\npossible d'utiliser un certificat et la clé privé associée. Les messages sont\nacheminés via le canal sécurisé mis en place par TLP.\n- Le Connection Protocol, multiplexe plusieurs canaux logiques (Shell\nX11...) dans le tunnel sécurisé. Les messages sont transportés par le User\nAuthentication Protocol.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Limitation des protections offertes par les pare-feu.", "section_path": ["Limitation des protections offertes par les pare-feu."], "page": 76, "content": "76\nLimitation des protections offertes par les pare-feu.\nFiltre\nInterne\nBastion\nFiltre\nDMZ\nExterne\nUn pare-feu48 filtre les paquets IP échangés avec un intranet en analysant\nl’entête d’un paquet IP, celui du protocole transporté, et parfois certains\nparamètres de l’application (mode proxy ou à états). Il y a un compromis\nentre la sévérité du filtrage (paquets IP fragmentés, paquets ICMP ou UDP)\net le degré de fonctionnalité/convivialité que l’on veut obtenir. Cependant\nun pare-feu ne protège pas des attaques internes, par exemple un cheval de\nTroie peut utiliser une session TCP pour échanger de l’information par\némission de données à l’extérieur des fenêtres de réception du destinataire,\nou par réémissions de segments déjà acquittés.\nDe manière analogue aux forteresses médiévales, on peut créer une zone\ndémilitarisée (DMZ) entre deux pare-feu, la DMZ accueille les serveurs\n48 Chuck Semeria, “Internet Firewalls and Security”, 1996\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Au sujet des normes Critères Communs (CC)", "section_path": ["Au sujet des normes Critères Communs (CC)"], "page": 77, "content": "77\nd’information de l’entreprise et un Bastion, un serveur spécialement sécurisé\npour la gestion d’information critiques accessibles depuis l’extérieur. Les\nréseaux externe et externe accèdent au Bastion et au serveur d’information.\nLe Bastion peut par exemple gérer le NAT du réseau interne.\nAu sujet des normes Critères Communs (CC)\nLes normes ISO 15408 dénommées Critères Communs visent à qualifier la\nsécurité de produits tels que microcontrôleurs sécurisés, cartes à puce ou\nfirewalls. Elles sont organisées en trois parties, introduction (partie 1),\nexigences fonctionnelles de sécurité (partie 2) et exigences d’assurances de\nsécurité (partie 3).\nUne évaluation CC est une procédure qui décerne un EAL (Evaluation\nAssurance Level) selon un document de référence, la cible de sécurité (Security\nTarget).\nLa cible de sécurité liste les exigences fonctionnelles de sécurité (CC partie\n2, par exemple identification et authentification - classe FIA) et les exigences\nd’assurance de qualité (CC partie 3, par exemple les tests – classe ATE) du\nproduit, c’est-à-dire le TOE (Target Of Evaluation) dans la terminologie CC.\nLes exigences fonctionnelles et d’assurances sont classées selon une\nhiérarchie à trois niveaux: classe-famille-composants. De manière\noptionnelle le TOE peut être décrit dans un Protection Profile (ou PP) qui est\ncommun à un ensemble de produits dont les fonctionnalités et les exigences\nde sécurité sont similaires.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Au sujet des normes Critères Communs (CC)", "section_path": ["Au sujet des normes Critères Communs (CC)"], "page": 78, "content": "78\nLes niveaux EAL se répartissent en sept catégories\n- EAL 7 conception formelle vérifiée et produit testé\n- EAL 6 conception semi-formelle vérifiée et produit testé\n- EAL 5 produit conçu de façon semi-formelle et testé\n- EAL 4 produit conçu, testé, revu de façon méthodique\n- EAL 3 produit testé et vérifié de façon méthodique\n- EAL 2 produit testé structurellement\n- EAL 1 produit testé fonctionnellement\nLe niveau augmenté (noté +) indique que lors de l’évaluation des\ninformations complémentaires, telles que les codes sources, sont connues.\nLes niveaux de produit bancaire sont par exemple EAL4+ ou EAL5, des\ncomposants logiciels complexes EAL1.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Programmes Malveillants, Virus, Vers", "section_path": ["Programmes Malveillants, Virus, Vers"], "page": 79, "content": "79\nHeuristiques d'Attaque\nL’intrusion.\nL’intrusion consiste à obtenir des autorisations (privilèges) illicites sur un\nsystème informatique afin d’accéder à des ressources\n(fichiers) ou de contrôler certaines ressources (accès\nréseaux…). Elle peut être menée par un utilisateur licite d’un\nsystème ou à l’aide de sessions réseaux. L’intrusion non\nautorisée de logiciel peut prendre la forme d’un virus, d’un\nver, ou d’un cheval de Troie.\nJames P. Anderson49 a proposé dans les années 80 une classification à\ntrois niveaux:\n- La mascarade. Exploitation illégitime d’un compte utilisateur (cassage\nde mot de passe …)\n- L’usurpation. Un utilisateur légitime qui étend ses privilèges.\n- L’usage clandestin. Le contournement des barrières de sécurité, la prise\nde contrôle du système.\nLa détection des intrusions est basée sur des collectes d’informations\n(audit, sondes réseaux…), sur la détection d’anomalies statistiques\n(moyenne, écart type, filtres bayésien…) ou la corrélation d’évènements\n(signature des attaques réseaux à l’aide de formules booléennes…).\nProgrammes Malveillants, Virus, Vers\nLes programmes malveillants sont de multiples natures, portes dérobées\n(backdoors, fonctionnalisées cachées), bombes logiques, chevaux de Troie,\nVirus, Vers.\nUn virus est un programme qui se duplique, on\ndistingue classiquement quatre phases : la phase dormante,\nla propagation, le déclenchement, l’exécution. Il se\ncaractérise par un code spécifique et un comportement\n(actions) typique sur un système informatique.\n49 James P. Anderson, Computer Security Threat Monitoring and Surveillance,\nJames P. Anderson Co, Fort Washington, PA (1980).\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Programmes Malveillants, Virus, Vers", "section_path": ["Programmes Malveillants, Virus, Vers"], "page": 80, "content": "80\nLes virus sont répartis50 selon quatre catégories principales, les virus\nsystèmes, les virus programmes, les virus interprétés, et les vers.\nLes virus systèmes sont dominants au début des années 90. Ils s'installent\ndans les secteurs de BOOT des disquettes ou dans les MBR (Master Boot\nRecord) des disques durs.\nLes virus programmes sont stockés dans des fichiers exécutables et se\npropagent dans de multiples fichiers.\nLes virus interprétés se propagent dans des macros (par exemple utilisés\ndans Microsoft Office) ou des scripts (par exemple JavaScript ou VBSript).\nUn vers est un programme malveillant qui se propage à travers le réseau.\nLes anti-virus mettent en œuvre des méthodes de détections basées sur :\n- la recherche de signature (un ensemble d'instructions, c'est une\nméthode peu efficace avec des virus polymorphes)\n- la recherche générique (recherche de sous ensembles d'instructions)\n- la recherche heuristique (ensemble d'instructions singulières et\nsuspectes)\n- le monitoring d'un programme (détection d'opérations non autorisées\nou suspectes)\nLe premier vers (IBM Christmas Tree) a été écrit par un étudiant Ouest\nAllemand en 1987 et diffusé sur la messagerie VNET. Un courrier\ncomportait un programme attaché christma.exec qui affichait des vœux et\nrediffusait le message à l'ensemble du carnet d'adresse du poste client.\n50 Vers et Virus, François Paget, DUNOD 2005\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Au sujet des botnets", "section_path": ["Au sujet des botnets"], "page": 81, "content": "81\nExemple le ver Blaster (2003)\nPrincipe du vers «Blaster» (2003)\nAu sujet des botnets\nLe terme botnet51 est la contraction des mots \"roBOT\" et \" NETwork\", soit\nlittéralement réseau de robots. Un robot est un programme effectuant des\nactions automatiques sur un serveur. Les premiers robots ont vu le jour dans\nle monde des opérateurs IRC. La dérive fut d’utiliser ces outils\nd’administration afin de prendre l’avantage lors de compétition pour le\ncontrôle d’un canal IRC. Le plus connu de ces outils est Eggdrop, apparu en\n1993. Le premier botnet W32/Pretty.worm ciblait des systèmes Windows dans\nles années 2000.\nUn botnet contamine un parc de systèmes informatiques, qualifiés de\nzombies. Le nombre de machines impliqués peut être de l’ordre de plusieurs\nmillions, par exemple pour le botnet Zeus. Il se propage selon différentes\ntechniques telles failles logicielles de systèmes d’exploitation, scripts ou\nprogrammes malveillants. Il utilise des canaux de commandes variés par\nexemple réseaux P2P ou échanges HTTP. Les botnets sont utilisés pour\ngénérer des SPAMs ou des attaques de type dénis de service (DDOS).\n51 F. Ducrot, M. Danho, X. Marronnier, SÉCURITÉ INFORMATIQUE, numéro\n61, CNRS, octobre 2007\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Le buffer overflow", "section_path": ["Le buffer overflow"], "page": 82, "content": "82\nAu sujet des rootkits\nUn rootkit est un logiciel malveillant furtif, c’est-à-dire qu’il masque son\nactivité dans un système d’exploitation (logs, liste des processus actifs,\ncommunications réseaux …). Il peut s'installer au sein d'un autre logiciel,\nune bibliothèque ou dans le noyau d'un système d'exploitation. Les premiers\nrootkits sont apparus en 1994 sur Linux et SunOS4; en 1998, sous Windows,\n(Back Orifice) et en 2004 sous Mac OS (X, WeaponX5).\nLe buffer overflow\nLe buffer overflow consiste à modifier malicieusement la mémoire d’un\nprogramme, typiquement lors de l’écriture d’une information localisée dans\nun paramètre d’appel du programme, ou lors de l’écriture de données\nreçues via le réseau (c’est-à-dire à l’aide des bibliothèques de sockets). Le\nlangage C utilise des chaines (char[]) de caractères dont la marque de fin est\nun octet nul. Les fonctions qui manipulent ces chaines (notées avec un\npréfixe s, par exemple strcpy,…), peuvent modifier une plage mémoire\nsupérieure à la taille allouée par le concepteur du programme. Par exemple\nchar name[12] ;\nchar *information; // la marque de fin est un octet nul\nstrcpy(name, information) ;\nSi la taille de information dépasse 12 octets, la mémoire allouée pour name\nest insuffisante, en conséquence une partie du contenu du pointeur\ninformation modifie la mémoire du programme de manière imprévue.\nLes effets espérés par les buffer overflow dans la pile d’exécution sont\nrépartis en trois classes principales\n- La modification d’une variable mémoire, proche de la zone mémoire\noccupée par le buffer, par exemple pour l'exploitation de \"use-after-free\nvulnerabilities\".\n- la modification de l’adresse de retour du programme localisée dans la pile, le\nbut étant l’exécution d’un code malveillant contenu dans un paramètre\nd’appel ou dans une information reçue via le réseau.\n- la modification d’un pointeur de fonction afin d’exécuter un code\npréalablement injecté.\nLes effets des buffer overflow dans la zone mémoire dite heap (ou tas) sont\ndifférents, car cette dernière est utilisée par les fonctions de type malloc\nréalisant les allocations dynamiques de mémoire.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Le buffer overflow", "section_path": ["Le buffer overflow"], "page": 83, "content": "83\nLe format ELF (Executable Linking Format),\nutilisé par de nombreux systèmes UNIX, (et\nWindows) est un exemple de l'architecture dite\nde Von Neumann dans laquelle le code et les\ndonnées sont logés dans une mémoire commune.\nIl existe un autre concept, l'architecture\nd'Harvard, dans lequel le code et les données sont\nstockés dans des mémoires distinctes; cette\ndernière approche est usuelle dans les\nenvironnements de type microcontrôleurs.\nLe format ELF définit cinq zones de mémoires virtuelles pour un\nprogramme, text pour le code, data pour les données initialisées, bss pour les\ndonnées non initialisées, la pile (stack) et le tas (heap) qui est la zone mémoire\nrestante intercalée entre pile et données.\nLe shellcode désigne un programme qui exécute un ensemble de\ncommandes du shell. Il est possible d’exécuter un shell dans un programme,\nà l’aide d’un appel système spécifique; un code malicieux exploite cette\nfonctionnalité. Une attaque consiste dans ce cas à injecter un shellcode puis à\nl’exécuter via des techniques de buffers overflow.\nEn 1988, un étudiant du MIT, Robert Tappan Morris, réalisa la première\nmise en œuvre offensive sur internet des techniques buffer overflow, nommée\nMorris worm.\nL'ouvrage52 \"Techniques de\nHacking\", de Jon Erickson, détaille les\ntechniques d'exploitation de buffer\noverflow et l'injection de code en\nparticulier de Shell Code. La zone de\ndonnées écrite à partir de l'adresse de\nbase du buffer comporte un code\nmalicieux (sans octet nul) et une série\nd'instructions NOP (no operation) qui\nécrasent l'adresse de retour du\ncompteur programme (PC) mémorisé dans la pile. Ce code tente une\nescalade de privilège (via la procédure setresuid()), afin d'exécuter un shell\n(tel que /bin/sh) en mode superviseur (root).\nLe Return-Oriented Programming (ROP) est une technique d'attaque\nmettant à profit des fragments de code se terminant par l'instruction return.\n52 \"Techniques de Hacking\", Jon Erickson, Pearson, 2009-2012\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Stratégie de défense du système Windows (2005)", "section_path": ["Stratégie de défense du système Windows (2005)"], "page": 84, "content": "84\nLe Fuzzing\nOn peut également citer les techniques fuzzing d’attaques de protocoles\nréseaux dont le principe est d’injecter des données aléatoires dans les\nlogiciels de traitement des piles (stack) de communication.\nL'injection SQL\nL’injection SQL consiste à importer des données qui sont des\ninstructions du langage de requêtes SQL. Par exemple un script PHP intègre\ndirectement dans une requête SQL, un login et un mot de passe renseignés\ndans un formulaire (HTML). Puisque ces paramètres sont des éléments du\nlangage, ils peuvent modifier malicieusement la requête; il devient en\nconséquence possible de valider un mot de passe erroné.\nLe Cross Site Scripting CSS\nLe Cross Site Scripting (XSS) consiste à injecter un script (javascript,\napplet, object) dans un formulaire HTML, dans un contexte ou l’application\nWEB affiche des contenus interactifs (blogs, etc…) pour ses utilisateurs. Le\nscript posté par l’attaquant sera par la suite téléchargé puis exécuté par les\nnavigateurs des clients (victimes) de l’application WEB.\nCross Site Request Forgery CSRF\nUne attaque CSRF force le navigateur d'une victime authentifiée à\nenvoyer une requête HTTP forgée, comprenant le cookie de session de la\nvictime, ainsi que toute autre information automatiquement inclue, à une\napplication web vulnérable.\nAutour de la Sécurité des Systèmes d'Exploitation\nStratégie de défense du système Windows (2005)\nVoici un bref résumé de la stratégie de sécurité d’un grand éditeur de\nlogiciels (Microsoft, RSA Security 2005).\n- Conception de systèmes d’exploitation résistant aux attaques (resilency),\nen particulier en introduisant la notion de comportements (behavior) basés\nsur des politiques d’usage de services.\n- Usage généralisé d’IPSEC et des VPNs pour les liens inter-entreprises.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Principes de sécurité du système Android", "section_path": ["Principes de sécurité du système Android"], "page": 85, "content": "85\n- Introduction des critères communs (quality) pour la conception de\nprogramme (Safe Programming).!\n- Généralisation de l’usage des pare-feu applicatifs.\n- Lutte contre le SPAM (?)\n- Concept du SD3+C (Secure by Design, Default, Deployment,\nCommunications)\n- Authentification à deux facteurs des utilisateurs, à l’aide de cartes à\npuce ou de jetons.\n- Participation des utilisateurs à la politique de sécurité grâce à\nl’éducation ou à la répression.\nPrincipes de sécurité du système Android\nAndroid est un système d’exploitation crée par la société Android Inc.\nrachetée en 2005 par GOOGLE. Il est aujourd’hui largement déployé dans\nles mobiles.\nLe système Android s’appuie sur un noyau UNIX. L’image binaire du\nsystème nommée ROM, contient le noyau, les librairies natives,\nl’environnement de la Dalvik Virtual Machine (DVM), le framework Java\n(JNI), et les applications.\nUne application Android comporte au plus quatre composants : l’activité,\nle service, le fournisseur de contenu et le receveur de broadcast. Les\ncomposants peuvent être déclarés publics ou privés. Les composants\nactivités, services, et broadcast receivers, sont activés par un message\nasynchrone dénommé Intent.\nLa sécurité android repose sur quatre piliers :\n- Les SANDBOXs Unix, associés aux processus\n- Les permissions.\n- La signature des applications\n- le chiffrement des fichiers.\nUn SANDBOX est un environnement logiciel qui contrôle les accès d’une\napplication aux ressources d’un système informatique géré par un système\nd’exploitation.\nPour le noyau Linux associé à Android, une application possède un user-\nid, un id de groupe et un id de groupe secondaire. Chaque application\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Intégrité du code, obfuscation, TPM", "section_path": ["Intégrité du code, obfuscation, TPM"], "page": 86, "content": "86\npossède des droits d’accès en lecture, écriture et exécution. C’est une\npolitique de contrôle d’accès discrétionnaire (DAC).\nLe système Unix possède un compte root dont le user-id est 0, et qui\npossède tous les droits. Chaque Application possède sa propre instance de\nDalvik Virtual Machine (DVM). Deux applications signées par une même clé\nprivée peuvent partager un Sandbox identique.\nLe fichier Manifest.xml définit la structure d’une application, c’est-à-dire\nla liste de ses composants. Il contient également les demandes de permission\nd’accès aux ressources du mobile et décrit les Intents traités par l’application.\nC’est le gestionnaire de la politique de sécurité de l’application.\nChaque application (.apk) doit être signée. Sous Eclipse on utilise les\noutils Keytool pour la génération de clés RSA dans un magasin de certificats\n(keystore), et Jarsigner pour la signature d’une application. Un certificat peut\nêtre auto-signé.\nIntégrité du code, obfuscation, TPM\nCertaines attaques intrusives sont liées à la possibilité de modifier le code\nd’un programme soit avant son exécution (modification du fichier\nexécutable) soit au cours de son exécution (point d’arrêts en mode debug,\nmodification de certaines zones mémoire, pose de bretelles….).\nL’analyse d’un code lors de son exécution révèle la clé associée à un\nalgorithme cryptographique. Cependant des techniques d’embrouillage de\ncode (obfuscation) ou de WBC (White Box Cryptography) peuvent rendre ces\nattaques plus difficiles.\nLe groupe Trusted Computing Group (TCG) a défini une architecture\nsécurisée pour les ordinateurs personnels basés sur un module hardware\nsécurisé le TPM (Trusted Platform Module). Dans ce modèle l’intégrité du\nsystème (bibliothèques essentielles du système d’exploitation,…) est\nmesurée (integrity measurement) par une empreinte (SHA-1, 160 bits) stockée\ndans une puce de silicium résistante aux attaques (tamper resistant). L’accès à\nce dispositif est contrôlé par des secrets partagés symétriques. Le TPM\ns’appuie sur un arbre de clés RSA, dont l’accès à chaque nœud est protégé\npar une clé symétrique. Remarquons à ce propos qu’une clé RSA de modulo\nN peut chiffrer les paramètres d’une autre clé RSA de modulo n=pq et\nd’exposants public et privé d,e tels que p<N, q<N, d<N, e<N.\nL’intégration du TPM dans le système d’exploitation Windows s’applique\naux trois points suivants:\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Cas d'usage: la sécurité des consoles de jeu XBOX (2002)", "section_path": ["Cas d'usage: la sécurité des consoles de jeu XBOX (2002)"], "page": 87, "content": "87\n- Le Secure Boot. Le premier programme amorce est stocké dans le TPM.\nLe boot est une succession de programme Pi tels que Po est contenu dans le\nTPM, chaque Pi est associé à une empreinte Hi enregistrée dans le TPM, le\nprogramme Pi-1 charge Pi et vérifie son empreinte Hi.\n- Le chiffrement du contenu du disque dur (bitlockerTM) à l’aide d’une clé\nmaître (VEK, Volume Encryption Key) stockée dans le TPM.\n- Le contrôle de l’intégrité des PCs au moment de leur connexion réseau\n(NAP, Network Access Protection).\nCas d'usage: la sécurité des consoles de jeu XBOX (2002)\nSecure Boot, XBOX 1.1\nAndrew Huang a publié53 en 2002 le reverse engineering de la sécurité\nde la console de jeu XBOX 1.0. Une ROM de faible capacité (512 octets) loge\nun code RC4, un interpréteur de commande, et réalise le déchiffrement et le\ncalcul du hash d'un code de boot de 2ième niveau stocké dans une mémoire\nflash. Il est important de noter d'un part que lorsque la valeur d'un hash de\nréférence est contenue dans la ROM, le contenu du boot de 2ième niveau ne\n53 Hacking the Xbox An Introduction to Reverse Engineering HACKING THE\nXBOX Andrew \"bunnie\" Huang, 2002\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Exemple de classification des attaques pour les systèmes embarqués.", "section_path": ["Exemple de classification des attaques pour les systèmes embarqués."], "page": 88, "content": "88\npeut être modifié, et d'autre part que le stockage de la clé cryptographique\n(RC4) est problème critique.\nEn octobre 2002 Andy Green a publié une analyse de la sécurité de la\nconsole de jeu XBOX 1.1. La ROM stocke et vérifie le hash d'un code stocké\nen mémoire flash. Ce dernier loge une clé publique et les ressources\nlogicielles nécessaires pour la vérification de signature RSA; il déchiffre et\nexécute un code de boot de 2ième niveau , dont il vérifie l'intégrité.\nDe manière générale un secure boot consiste en une succession d'exécution\nde blocs logiciels, optionnellement chiffrés, après vérification de leur\nintégrité.\nExemple de classification des attaques pour les systèmes embarqués.\nS. Ravi et al, 2004\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Secure Elements", "section_path": ["Secure Elements"], "page": 89, "content": "89\nSecure Elements\nUn secure element est un microcontrôleur sécurisé54 55 (de surface\ninférieure à 5x5 mm2), muni d’une interface de\ncommunication (série, USB,…) qui résiste à des\nattaques physiques et logiques. Bien que des\ncomposants de 16 ou 32 bits existent, le CPU le\nplus fréquemment utilisé est basé sur une\narchitecture 8 bits (par exemple le 6502,\nmicroprocesseur de l’Apple II). La taille des\nmémoires embarquées est de l’ordre d’une\ndizaine de KB pour la RAM, 100KB pour la\nFLASH qui contient le code des applications, et quelques centaines de\n100Ko pour la ROM qui stocke un système d’exploitation.\nScalable EEPROM RAM Hidden\nEvent Register Clock UART 400 KB 16 KB ROM\nCode/Data 80KB\nVoltage/Filter\nVoltage 32 bits CPU\nClock With\nReset Memory\nTemperature 32 bits bus Management\nAnd Protection\nUnit\nVoltage 16-bit Crypto DES Random\nRegulator Timers Accelerator Accelerator Number\nRSA 1408 bit Generator\nLes attaques physiques comprennent;\n La pose de microsondes à la surface du circuit. L’attaquant désire\nobtenir les secrets stockés dans la mémoire non volatile, par exemple en\nl’isolant la mémoire du reste de la puce sécurisé, et en produisant les\nsignaux électriques nécessaires à sa lecture;\n Le reverse engineering, reconstruction du layout de la puce,\nvisualisation du code ROM, et plus généralement identification des\ncontres mesures;\n L’injection de faute. Grâce à des interactions physiques (coupure\nd’alimentation, glitches de tension, injection laser, etc..) on perturbe le\nfonctionnement normal du microcontrôleur, dans le but de produire des\n54 Smart Cards - The developer’s Kit. Timothy M. Jurgensen, Scott B. Guthery.\nEditions Prentice Hall\n55 Smart Card handbook. W. ERankl , W. Effing. Editions Willey\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Secure Elements", "section_path": ["Secure Elements"], "page": 90, "content": "90\nerreurs permettant de déduire la clé d’un algorithme cryptographique ou\nde contourner certaines procédures logicielles (code PIN,…).\nLes contre mesures physiques intègrent le chiffrement du bus système, le\nchiffrement des mémoires, la détection de paramètres de fonctionnement\n(température, alimentation, fréquence) anormaux, la perte d’intégrité physique\n(treilli métallique actif), l’absence de rayonnement radio (plan de masse métallique),\nun design désordonné (fuzzing design) pour masquer les structures fonctionnelles\n(mémoires,…)\nStructure d’un système d’exploitation de secure element56\nLes attaques logiques comprennent\n Les attaques temporelles (moyenne, écart type). Certaines\nimplémentations d’algorithmes présentent des temps de calcul différents\nen fonction des valeurs d’entrée et de la clé utilisée.\n Les attaques par corrélation statistique, telles que Simple Power Attack\n(SPA) ou Differential Power Analysis (DPA). Un processeur réalise un\nalgorithme à l’aide d’une suite d’opérations nécessairement différentes\nen fonction de la clé. Ainsi un algorithme utilisant une clé parmi 2p\npossibles, traite au moins p informations différentes pour une clé\nparticulière. Il produit donc des signaux électriques (par exemple\npuissance consommée) ou radioélectriques qui sont corrélés à la clé\nopérationnelle.\nBeaucoup de secure elements intègrent57 une machine virtuelle java\n(JVM) qui exécute des applications écrites en javacard. Les applications sont\n56 MASSC: a generic architecture for multi application smart cards. IEEE Micro\n19(5): 52-61 (1999)\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "3 Tim Berners-Lee. \"The World Wide Web\", Poster, ACM Hypertext", "section_path": ["3 Tim Berners-Lee. \"The World Wide Web\", Poster, ACM Hypertext"], "page": 91, "content": "91\nchargées via un canal sécurisé (Secure Channel), normalisé par les standards\nGlobal Platform.\nTrusted Execution Environment\nUn processeur TEE, par exemple TrustZone58 de la société ARM, réalise\nla virtualisation d’un processeur permettant la création de deux espaces de\ntraitement de l’information le \"Normal Word\" et le \"Secure World\". Chacun de\nces modes de fonctionnement possède un banc de registres séparé et des\nmécanismes d’interruption différents. Cependant le CPU et les mémoires\ninternes (ROM, SRAM) sont communs aux deux mondes. Une troisième\nentité, le Monitor gère les changements de contexte entre le \"Normal Word\" -\nNW- et le \"Secure World\" -SW- à l’aide d’instructions spécifiques (Secure\nMonitor Call, SMC); elle se comporte de fait comme un hyperviseur qui\nréalise grâce à la technique de virtualisation, une isolation des espaces dits\nnormaux ou sécurisés.\nLes tailles mémoire internes sont de l’ordre de 10 Ko pour la ROM et 128\nKo pour la SRAM. Ces capacités limitées expliquent la compétence native\ndes industriels de la carte à puce pour la conception de systèmes\nd’exploitation sécurisés compatibles avec ces modestes ressources.\nD’un point de vue physique, et contrairement aux Secure Elements, le\nprocesseur n’implémente pas de contremesures matérielles. (\"Hardware\ntechniques and processes used for smartcards are impractical for standard Soc\ndesigns…\"). La technologie SoC permet cependant d’intégrer des blocs\ncryptographiques démunis cependant de protections hardware.\n57 Java CardTM Technology for Smart Cards. Zhiqun Chen. Editions Addison\nWesley\n58 ARM Security Technology, Building a Secure System using TrustZone®\nTechnology\", 2009, http://infocenter.arm.com/help/topic/com.arm.doc.prd29-genc-\n009492c/PRD29-GENC-009492C_trustzone_security_whitepaper.pdf\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Hardware Secure Module (HSM)", "section_path": ["Hardware Secure Module (HSM)"], "page": 92, "content": "92\nLes mémoires externes non volatiles (ROM, FLASH) ou volatiles\n(DRAM…) sont partagées par les deux mondes. Une entité MMU (Memory\nManagement Unit) réalise les partitions nécessaires à leur virtualisation; des\nprotections cryptographiques (chiffrement et intégrité) sont nécessaires pour\nla sécurité des informations stockées par le \"Secure World\". Le MMU assure\négalement les partitions mémoires internes au SoC.\nLa référence59 détaille une injection de code arbitraire dans\nl'environnement de confiance QSEE, exploitant une faille de type buffer\noverflow détectée dans le trustlet Widevine.\nHardware Secure Module (HSM)\nUn Hardware Secure Module est un système informatique \"durci\", qui\nrésiste à des attaques physiques, avec des assurances de sécurité de EAL1 à\nEAL4, selon une échelle Critère Commun (CC) qui comporte 7 niveaux. Sa\nfonction est d’exécuter des algorithmes cryptographiques symétriques ou\nasymétriques. Il est conçu par exemple pour effacer les clés\ncryptographiques lors d’une intrusion physique. Typiquement son\ndémarrage nécessite une carte à puce qui contient les clés nécessaires au\ndéchiffrement des mémoires stockant les secrets.\nLe standard FIPS 140-2 définit quatre niveaux de sécurité pour les HSM\nLe niveau 1 utilise un algorithme cryptographique normalisé, exécuté sur\nun système d’exploitation standard. Une carte de chiffrement peut être mise\nen œuvre.\n59 https://bits-please.blogspot.fr/2016/05/qsee-privilege-escalation-\nvulnerability.html\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Intel SGX", "section_path": ["Intel SGX"], "page": 93, "content": "93\nLe niveau 2 utilise un boitier physique fermé et sécurisé (notion de tamper\nresistance). Il met en œuvre un contrôle d'accès au module cryptographique,\nbasé sur les rôles (Role-Based Access Control - RBAC) ; il est exécuté sur un\nsystème informatique classique dont le système d'exploitation répond aux\nexigences fonctionnelles spécifiées dans les profils de protection (PP) critères\ncommuns (CC). Il est associé à un profile de protection EAL2.\nLe niveau 3 implémente la détection des intrusions physiques,\nimpliquant l’effacement des secrets. Il met en œuvre une authentification des\nrôles basée sur l’identité. Des interfaces d’entrée/sortie dédiées doivent être\ndisponibles pour l’administration. Il est associé à un profile de protection\nEAL3.\nLe niveau 4 réalise la détection d’intrusion logique et physique renforcée,\npar exemple il identifie les paramètres fonctionnels (température,\nalimentation, horloge …) anormaux, et implémente des contremesures. Il est\nassocié à un profile de protection EAL4.\nIntel SGX\nLa technologie SGX60 61 62 63 est une exécution isolée dans un processeur\nINTEL multi-cœurs, selon la notion d’enclave. Elle est conçue pour résister\naux malwares présents au niveau du système d’exploitation. Un logiciel\n(ISV) crée une enclave à partir d’instructions dédiées SGX. L’identité de\nl’enclave (\"Enclave Identity\") est l’empreinte mémoire (hash) du logiciel et\nd’autres données. Le \"Sealing Identity\" est un certificat émis par le \"Sealing\nAuthority\" pour certifier \"Enclave Identity\", ainsi que d’autres informations,\npar exemple un identifiant de produit.\nL'attestation logicielle prouve à un ordinateur distant qu'il communique\navec un conteneur sécurisé (son image mémoire est chiffrée,) spécifique\n60 Victor Costan and Srinivas Devadas, Intel SGX Explained, 2016\n61 JP Aumasson, Luis Merino, SGX Secure Enclaves in Practice Security and\nCrypto Review, Blackhat 2016\n62 https://software.intel.com/content/www/us/en/develop/articles/innovative-\ntechnology-for-cpu-based-attestation-and-sealing.html\n63 https://sgx101.gitbook.io/sgx101/sgx-bootstrap/overview\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Intel SGX", "section_path": ["Intel SGX"], "page": 94, "content": "94\nhébergé par une plate-forme de confiance. La preuve est une signature\nd’attestation produite par la clé d’attestation secrète de la plate-forme. La\nsignature couvre l’état initial du conteneur, un nonce de défi produit par\nl’ordinateur distant et un message produit par le conteneur.\nEn phase de production deux secrets hardware sont générés :\n- Le root provisioning key\n- Le root seal key , qui n’est pas connu d’INTEL\nLe root seal key est utilisé pour calculer des seal keys pour les enclaves\nL’Attestation prouve l’intégrité d’une enclave\n- Une enclave particulière Quoting Enclave (QE) génère une clé de\nsignature asymétrique EPID.\n- QE mesure l’intégrité d’une enclave et délivre une attestation de\nvérification.\nNotion de Sealed storage\n- Après la création d’une enclave les données internes de l’enclave sont\nprotégées au runtime par une clé Seal Key\n- Des secrets peuvent être crées par l’enclave et stockés à l’extérieure de\nl’enclave selon un mécanisme dit Encrypted blob.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Obfuscation", "section_path": ["Obfuscation"], "page": 95, "content": "95\nObfuscation\nL'objectif des techniques d'obfuscation logicielle (soit P un programme,\nnote O(P) sa forme après obfuscation) est de rendre difficile l'analyse d'un\nprogramme (selon64 \"Code obfuscation is the practice of making code\nunintelligible, or at the very least, hard to understand\").\nSelon le classique paradigme de programmation procédurale, un\nprogramme est un ensemble de procédures, d'instructions, de branchements\n(jump), et de données. Le graphe CFG (Control Flow Graph) est une\nreprésentation de la structure des appels de procédures et des instructions\nde saut. Rendre un programme inintelligible consiste à rendre très difficile\nson analyse (reverse engineering) et en particulier l'extraction d'un CFG (voir\npar exemple la référence65). Un mécanisme deobfuscation (soit retrouver P à\npartir de O(P)) peut être un problème NP complet.\nExemple de graphe CFG (Control Flow Graph)\nLes virus utilisent des techniques polymorphes ou métamorphes.\n- Dans le cas du polymorphisme, une clé modifiée à chaque instanciation\ndu programme déchiffre des sous ensembles, qui sont chiffrés\nultérieurement avec une nouvelle clé.\n-Dans le cas du métamorphisme, le programme polymorphe modifie tout\nou partie de son code, qui est recompilé par la suite.\nL'obfuscation et la sécurité sont cependant deux notions distinctes. Ainsi\naprès obfuscation, un algorithme cryptographique (DES par exemple) reste\n64 A. Balakrishnan and C. Schulze, \"Code Obfuscation Literature Survey\",\nhttp://pages.cs.wisc.edu/~arinib/writeup.pdf, 2005.\n65 Emmanuel Fleury, \"Binary Program Analysis: Theory and Practice (what you\ncode is not what you execute)\"\nhttp://www-verimag.imag.fr/~async/CCIS/talk_13/Fleury.pdf\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Obfuscation", "section_path": ["Obfuscation"], "page": 96, "content": "96\nexposé aux attaques par injections de faute, SPA (Single Power Analysis) ou\nDPA (Differential Power Analysis).\nLe document66 \"Code Obfuscation Literature Survey\" résume les différentes\ntechniques pouvant être mises en œuvre:\n- Modification du flux de control du programme (suite de blocs\nd'instructions en mémoire sans saut, et appels de procédures), répartition\naléatoire de blocs d'instructions en mémoire, instructions de saut opacifiées\nà l'aide de prédicats (par exemple un appel de procédure remplace une\ninstruction jump);\n-Modification des abstractions du logiciel, telles que relations d'héritage\nou tableaux de données;\n- Mise en œuvre d'une machine virtuelle (interpréteur) par le\nprogramme, exécutant ses propres instructions (et donc différentes de celles\ndu processeur exécutant le programme);\n- Insertion et destruction de code en mémoire au runtime (inline and\noutline method);\n- séparation de variables;\n- concaténation de variables;\n- conversion de variables en procédures.\nL'analyse de programme se décompose en deux classes fonctionnelles:\n- L'analyse statique qui examine le code source du programme afin d'en\nextraire un CFG et certaines informations (des clés cryptographiques par\nexemple). En code assembleur (binaire) cette opération peut être rendue\ndifficile par l'insertion de zones de données dans le code. En java le code et\nles données sont séparés dans des zones distinctes du fichier .class. La Dalvik\nVirtual Machine (DVM) d'Android est similaire à la machine virtuelle Java\n(JVM), des outils libres publiques (\"désassembleur\") permettent la\ntransformation de code DVM en JVM, et donc l'analyse statique d'un fichier\nAndroid PacKage (APK). Cependant il est possible d'inclure du code C dans\nune application Android, compilée pour un processeur spécifique (et donc\nun modèle de mobile donné) grâce aux interfaces JNI (Java Native Interface).\n- L'analyse dynamique, réalisée lors de l'exécution du programme (run\ntime).\n66 A. Balakrishnan and C. Schulze, \"Code Obfuscation Literature Survey\",\nhttp://pages.cs.wisc.edu/~arinib/writeup.pdf, 2005.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "White-Box Cryptography (WBC)", "section_path": ["White-Box Cryptography (WBC)"], "page": 97, "content": "97\nIndistinguishability Obfuscation\nL'idée intuitive de l'obfuscation67 est de construire une boite noire (Black\nBox) qui ne délivre aucune information au cours de son fonctionnement.\nEn 2001 le célèbre article68 \"On the (Im)possibility of Obfuscating Programs\"\na démontré que le concept de boite noire n'est pas universel, c'est à dire qu'il\nest toujours possible, quelque soit le procédé d'obfuscation, d'extraire de\nl'information de certaines fonctions, similaires à des procédures à sens\nunique (fonction de hash). Cependant le même article introduit la notion\nd'obfuscation non distinguable (Indistinguishability Obfuscation, iO) telle que\nles obfuscations iO(P1) et iO(P2) de deux variantes fonctionnellement\néquivalentes d'un programme (par exemple P1= !a + !b, et P2= !a.b) soient\nindiscernables.\nSelon une approche circuit, un algorithme (C1) conçu sous la forme\ncanonique conjonctive (ensemble de AND de termes comprenant des OU de\nvariable logique et de leur négation NOT) serait indiscernable d'une\ninstanciation équivalente C2= iO(C1). Par la suite l'extraction d'information\n(soit l'obtention de la forme canonique C1 à partir de C2) est impossible en\nraison du problème bien connu SAT, qui est NP complet. Les algorithmes\ncryptographiques basés sur le principe iO, sont potentiellement capables de\ndissimiler certaines informations (clés) mais en sont encore au stade de la\nrecherche.\nWhite-Box Cryptography (WBC)\n67 Marc Beunardeau ; Aisling Connolly ; Remi Geraud ; David Naccache, \"Cdoe\nObofsucaitn: Securing Software from Within\", IEEE Security & Privacy Issue 3 •\nMay-June 2016\n68 B. Barak et al., \"On the (Im)possibility of Obfuscating Programs,\" Proc. 21st\nAnn. Int’l Cryptology Conf. (CRYPTO 01), LNCS 2139, Springer, 2001, pp. 1–18\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "White-Box Cryptography (WBC)", "section_path": ["White-Box Cryptography (WBC)"], "page": 98, "content": "98\nLa technique de White Box a été proposée en\n200269. Son objectif70 est de réaliser\nl'obfuscation logicielle d'une clé associée à un\nalgorithme cryptographique par exemple DES ou\nAES. Le code implémentant l'algorithme peut\nêtre cloné, mais l'extraction de la clé est\nprésumée impossible. L'algorithme de\nchiffrement est transformé en un réseau de tables\n(lookup table) liées à la clé (S-Box modifiées).\nUne table S établit une relation entre un index (6 bits pour le DES) et une sortie\n(4 bits pour le DES), index = K exor E (K est une sous clé DES de 6 bits), Y =\n6 6 6 6 4\nS(index). Soit un index ’ = index exor K , on obtient une table Y = S(index ’). En\n6 6 6 4 6\nappliquant la relation index ’ exor E on retrouve index , et donc Y = S(index ’ exor\n6 6 6 4 6\nE ). Le code est par la suite embrouillé selon des techniques d'obfuscation.\n6\nLes implémentations DES et AES en white box ont été cassées71 par des\nattaques dites DCA (Differential Computation Analysis).\nLors de la conférence BlackHat une série d'attaques72 (injection de fautes et\nanalyse Differential Fault Analysis - DFA) a été démontrée sur des implémentations\ncommerciales.\nLe WhibOx challenge est une compétition WBC (https://whibox-\ncontest.github.io/ ), appliquée à l'algorithme AES. Son objectif est la réalisation d'un\nprogramme en C, qui calcule un chiffrement AES avec une clé de 128 bits. Le code\ncomporte la fonction :\nAES_128_encrypt(ciphertext, plaintext)\nLes attaquants disposent du code source et tentent de casser le programme, c'est\nà dire d'obtenir la clé secrète AES, par tous les moyens disponibles. En 2017 la\ngrande majorité des programmes ont été cassés en moins d'une heure; quelques\nimplémentations ont résistées plus de 10 jours, et le record est d'environ un mois. En\n2019 plusieurs implémentations ont résisté pendant la durée du concours\n69 Stanley Chow & All. \"A white-box DES implementation for DRM\napplications\", in Proceedings of the ACM Workshop on Security and Privacy in\nDigital Rights Management (DRM 2002), volume 2696 of Lecture Notes in\nComputer Science, pages 1–15. Springer, 2002.\n70 Brecht Wyseur, Nagra Kudelski, \"White-Box Cryptography: Hiding Keys In\nSoftware\", MISC 2012.\n71 Joppe W. Bos, et Al, \"Differential Computation Analysis: Hiding your White-\nBox Designs is Not Enough\"; 2016.\n72 Eloi Sanfelix, Cristofaro Mune, Job de Haas, \"Unboxing the White Box\",\nBlackHat 2016\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Les implants matériels", "section_path": ["Les implants matériels"], "page": 99, "content": "99\nIntégrité physique et logicielle\nL’intégrité physique et logicielle est un enjeu majeur pour la\ncybersécurité. Comment avoir une certaine assurance sur l’absence de\nmalware dans un logiciel embarqué, et sur la conformité du hardware (carte\nélectronique et composants) associés.\nIntégrité physique\nLes implants matériels\nUn implant est une puce (chip) insérée dans un système électronique,\ndans le but de réaliser des fonctions malicieuses.\nLe 8 octobre 2018 la revue Bloomberg Business week a publié un article\nintitulé \"The Big Hack: How China Used a Tiny Chip to Infiltrate U.S.\nCompanies\", lequel s’est avéré par la suite totalement infondé. L’article\ndécrit une puce électronique (un implant) de la taille d’une pointe de crayon,\nsoudée sur une carte mère destinée à des environnements cloud, et\nembarquant des ressources réseau\nCependant en 2020 lors de la conférence CS3sthlm73 le chercheur Monta\nElkins a présenté dans sa communication \"Nation-\nState Supply Chain Attacks for Dummies and You Too\"\nun implant basé sur le processeur ATTINY85 (8Ko\nFLASH, 512 octets EEPROM, 512-octets SRAM,). Ce\nboitier de petite taille (4x4x0.8mm) monté sur un\nmodule (DigiSpark) coute 1$ il est programmable\navec l’IDE Arduino. L’implant est soudé sur la carte\nmère du routeur CISCO ASA5505. Le principe de\nl’attaque consiste à injecter lors du boot, des commandes sur l’interface série\ndisponible pour l’administration du dispositif. Le micro logiciel crée un\ncompte SSH permettant l’accès au routeur à distance et signale cette\nopportunité par une série de ping sur un serveur de l’attaquant.\nD’autres idées d’implant visent les claviers, par exemple le projet\nHaunted USB Cable74) (2010) utilise une puce ATTINY45 insérée dans une\nprise USB, qui réalise l’émulation d’un clavier USB HID (Human Interface\nDevice). Le micro logiciel modifie de manière aléatoire les modes CapsLock,\n73 https://www.youtube.com/watch?v=WTncGSYSbNY\n74 http://imakeprojects.com/Projects/haunted-usb-cable\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Les relais", "section_path": ["Les relais"], "page": 100, "content": "100\nInsert, et NumLock, et injecte des caractères espace, backspace, tab, or\ndelete.\nEn 2016 le projet75 a adapté le micro logiciel Haunted USB pour un\nprocesseur ATTINY85. La même année un autre projet76\na développé une variante logicielle qui injecte une série\nde caractères après trois pressions de la touche\nCapsLocks. Les claviers sont équipés de trois voyants\nindiquant l’activation des modes scroll lock, caps lock et\ninsert. Le système d’exploitation envoie des messages\nUSB HID pour synchroniser les affichages de plusieurs claviers. La séquence\nd’échange est la suivante:\n1) la touche caps lock est pressée; 2) le micro logiciel du clavier notifie cet\névènement dans un \"input report\"; 3) le PC diffuse un message \"output\nreport\" pour l’activation de la LED correspondante; 4) le micrologiciel active\nla LED.\nSous Windows des API dédiées permettent la gestion des différents\nmodes d’un clavier. Il est donc possible d’établir un canal caché avec un\nmalware HID USB.\nCertains modules Arduino, par exemple basés sur le processeur\nATMEGA32u4 supportent des librairies HID réalisant des interfaces clavier\net souris. L’ajout d’un SoC de communication, tel que Bluetooth ou Wi-Fi,\npermet d’injecter des messages indiquant le déplacement du curseur ou la\nfrappe de touche. Typiquement l’attaque consiste à démarrer un shell pour\nexécuter des commandes.\nLes relais\nLes attaques par relais (Relay Attack) s’appuient sur une technique de\ntype MIM (Man In the Middle) dont le but est d’étendre la distance de\nfonctionnement, et/ou de transmettre partiellement les informations reçues.\nPar exemple on peut relayer des signaux radio; des attaques SARA\n(Signal Amplification Relay Attacks) sont été constatées pour le vol de voiture\néquipées de systèmes RKS (Remote Keyless System). Une clé électronique\ndétecte en permanence les signaux émis à courte portée par les véhicules,\nqui sont déverrouillés au terme d’un échange d’authentification.\n75 https://github.com/whiteneon/haunted-usb-1.0\n76 https://github.com/Uxio0/usbAspKeyboard\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Les relais", "section_path": ["Les relais"], "page": 101, "content": "101\nEn 2005 un article de Gerhard Hancke77 démontrait l’usage à distance de\ncarte MIFARE largement déployé pour le contrôle d’accès. Le relais\ntransporte le contenu de trames MAC à travers internet. Les temps de\nréponse sont plus importants, ce qui est détectable par des contre mesures.\nSelon le même principe, des attaques sont possibles entre un terminal de\npaiement et une carte bancaire sans contact, au moyen d’un relais des\ncommandes ISO7816, dites APDUs.\nEn 2010 une équipe de chercheurs78 de l’Université College London et de\nl’université de Cambridge ont démontré une faille de sécurité dans le\nprotocole EMV. L’évènement \"Code PIN non renseigné\" n’est pas mémorisé\ndans le cryptogramme de paiement, ce qui rend possible une attaque par\nrelais. Ils ont développé un système électronique qui transmet toutes les\ncommandes ISO7816 à la puce EMV authentique, sauf la commande\nVerifyPIN, pour laquelle le relais délivre la réponse ISO7816 0x9000 (soit\nPIN OK). Cette faille rend possible l’usage de cartes volées.\nEn mai 2011, le GIE Cartes Bancaires a constaté qu'une dizaine de cartes\nEMV, volées en France quelques mois\nauparavant, étaient utilisées en Belgique. Une\nenquête policière a été ouverte, des cartes\nfrauduleuses ont été saisies et expertisées.\nL’article79 présente les résultats de cette\nexpertise mettant en évidence l’usage d’un\nsystème relais nommée FUN, comportant une\nmémoire EEPROM 8Ko série (AT24C64), et le\nprocesseur AT90S8515A (512o EEPROM, 512o\nRAM). FUN est une version très intégrée du\nprototype de l’équipe anglaise; c’est un en fait\nun implant collé sur le module EMV\nauthentique.\n77 Gerhard Hancke \"A Practical Relay Attack on ISO 14443 Proximity Cards”,\n2005\n78 Steven J. Murdoch, Saar Drimer, Ross Anderson, Mike Bond, \"Chip and PIN\nis Broken\", 2010 IEEE Symposium on Security and Privacy.\n79 Houda Ferradi, Rémi Géraud, David Naccache, and Assia Tria, \"When\nOrganized Crime Applies Academic Results A Forensic Analysis of an In-Card\nListening Device\", October 2015, Journal of Cryptographic Engineering.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Anti clonage de processeur : techniques SRAM PUF", "section_path": ["Anti clonage de processeur : techniques SRAM PUF"], "page": 102, "content": "102\nAnti clonage de processeur : techniques SRAM PUF\nUne puce électronique peut être remplacée par un clone aux\nfonctionnalités identiques, ou par un système réalisant son émulation. Les\ntechniques PUF80 (physical unclonable function) permettent d’identifier une\nmémoire SRAM de manière pseudo unique.\nUn microcontrôleur (MCU) comporte une unité arithmétique et logique\n(ALU) des mémoires non volatiles (EEPROM,\nFLASH) et éphémères (SRAM). Le rapport de\nsurface entre mémoire FLASH et SRAM est\nd’environ 4 (?).\nUne cellule SRAM classique est réalisée par 6\ntransistors CMOS, réalisant deux inverseurs\nconnectés en série afin de provoquer un état\nbistable. Idéalement pour des faibles valeurs de\ntension d’alimentation VDD les sorties des\ninverseurs restent proches de VDD/2, avec un\ngain croissant. Si les inverseurs sont\nparfaitement symétriques, la tension de sortie suit VDD/2, et bascule de\nmanière aléatoire (avec une probabilité de 50%) vers 0 ou VDD. Cependant\nen fonction de dissymétries géométriques ou électriques des transistors\nCMOS, une cellule mémoire peut prendre une valeur fixe (0 ou 1) de\nmanière reproductible (avec une probabilité très proche de 1). Cet effet peut\nêtre mis à profit pour identifier une mémoire SRAM intégrée dans un MCU.\n80 Charles Herder, Meng-Day Yu, Arinaz Koushanfar, Rinivas Devadas,\n\"Physical Unclonable Functions and Applications: A Tutorial\", in IEEE Volume\n102, Issue: 8, Aug. 2014.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Anti clonage de processeur : techniques SRAM PUF", "section_path": ["Anti clonage de processeur : techniques SRAM PUF"], "page": 103, "content": "103\nLa figure ci-dessus monte l’état d’une mémoire SRAM pour deux MCUs\nATMEGA8 (à gauche et à droite) après 250 mises en tension. Les carrés\nblancs indiquent les cellules mémoires bruitées (c'est-à-dire observées avec\ndes valeurs de sorties différentes). Au centre elle montre une image mémoire\npour une mise en tension unique.\nLa figure ci-dessus montre les contenus de cellules mémoires différents\n(en rouge) pour deux processeurs (les points bruités en blanc sont ignorés);\nelle démontre l’authentification (statique) de SRAM par un procédé PUF. On\npeut utiliser des cellules SRAM avec des contenus invariants, et protégées\nd’éventuelles erreurs par des codes auto correcteurs, comme des clés\nprivées, par exemple de taille 256 bits. Cependant les calculs\ncryptographiques associés permettent de récupérer ces clés, si des\ntechniques de canaux cachés sont pertinentes.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attestation distante (remote attestation)", "section_path": ["Attestation distante (remote attestation)"], "page": 104, "content": "104\nAttestation distante (remote attestation)\nL'attestation81 est une procédure consistant à affirmer (à un évaluateur)\nune propriété (claim) d’une cible, à l’aide de preuves démontrant cette\npropriété.\nL'attestation à distance82 est un mécanisme qui permet à un évaluateur\n(Verifier) de vérifier l'intégrité d'un système hôte (distant) qui est dans un\nétat connu, selon un mécanisme de défi-réponse. Les principales entités d’un\ntel protocole sont le Prover (P) et le Verifier (V). Typiquement le Verifier\nproduit un nombre aléatoire (nv), le Prover génère des données d’attestation\n(att_data(nv)) et retourne cette information optionnellement munie d’une\nsignature cryptographique.\nOn distingue trois classes d’attestation:\n(1) Attestation logicielle, le mécanisme d'attestation repose sur des\nmesures de temps strictes.\n(2) Attestation matérielle, la procédure d’attestation utilise un composant\nmatériel durci (\"tamper-resistant\", tel que TPM par exemple).\n(3) Attestation hybride, la procédure d'attestation utilise des ressources\nlogicielles et matérielles. Par exemple un code stocké dans une mémoire\nROM réalise le Prover.\n81 George Coker, Joshua Guttman, Peter Loscocco1, Amy Herzog,Jonathan\nMillen, Brian O'Hanlon, John Ramsdell,Ariel Segall, Justin Sheehy, and Brian\nSniffen, \"Principles of Remote Attestation\"\n82 IOANNIS SFYRAKIS and THOMAS GROSS,\"A Survey on Hardware\nApproaches for Remote Attestation in Network Infrastructures\"\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Intégrité logicielle pour un système embarqué", "section_path": ["Intégrité logicielle pour un système embarqué"], "page": 105, "content": "105\nLes attaques83 logicielles possibles sont par exemples\n1. Le pré-calcul de tous les résultats d'attestation, indépendamment du\ndéfi.\n2. Le rejeu d’un résultat, ou la réponse d’un autre dispositif.\n3. La copie mémoire totale (Memory Copy).\n4. La substitution de données (copie partielle).\n5. La Compression.\n6. L’usurpation d'identité, envoi d’une réponse invalide ou l’usage de\ndispositifs valides.\n7. La technique ROP (Return Oriented Programming). Exécution de\nfragment de code.\nDes attaques matérielles peuvent effacer un dispositif authentique,\nutiliser un dispositif authentique localement (implant) ou à distance (relais).\nIntégrité logicielle pour un système embarqué\nUn logiciel peut il prouver son intégrité dans un contexte de système\nembarqué ?\nConsidérons un microcontrôleur équipé de mémoires non volatile et\néphémères. On peut remplir la mémoire d’instructions non utilisée par un\ncontent pseudo aléatoire pour éviter les attaques de type \"memory copy\", et\nde même pour la mémoire SRAM non utilisée pour les données. L’utilisation\nde procédure de compression/décompression augmente le temps de calcul.\nL’idéal serait de concevoir un algorithme optimal en termes de taille\nmémoire et de temps d’exécution84. Les invariants mis en œuvre sont la\ntaille finie des mémoires et le temps. Voici deux exemples illustrant la\npreuve d’intégrité de logiciel.\n83 Sigurd Frej Joel Jorgensen Ankergard, Edlira Dushku and Nicola Dragoni,\nState-of-the-Art Software-Based Remote Attestation:Opportunities and Open Issues\nfor Internet of Things\n84 Asokan, N. et al. \"ASSURED: Architecture for Secure Software Update of\nRealistic Embedded Devices.\". IEEE Transactions on Computer-Aided Design of\nIntegrated Circuits and Systems 37.11 (2018): 2290-2300.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Bijective MAC, BMAC", "section_path": ["Bijective MAC, BMAC"], "page": 106, "content": "106\nRemote Attestation\nL'attestation à distance\n(\"remote attestation\") est\nun processus dans\nlequel une entité de\nconfiance (\"verifier\")\nmesure à distance l'état\ninterne d'un système\npotentiellement\ncompromis, à l’aide\nd’un programme dit\n\"prover\". L’idée est de\nréaliser un checksum\nou un hash sur les\nmémoires du système,\ndans un ordre pseudo\naléatoire, fixé par une\npermutation.\nPar exemple l’article85 utilise une permutation86 P dans Z/2n, c'est-à-dire\npour un espace d’adresses de 2n cellules.\nLes bits 0 et 3 de C doivent être à 1, soit C = 5 v X mod 2n L’opération\ncarré est réalisé par un multiplicateur câblé, ce qui garanti un temps\nd’exécution minimal. L’algorithme Prover calcule un checksum des\nmémoires du système, le nombre d’itération étant aléatoirement fixé par le\nvérificateur, à l’aide d’une implémentation supposée optimale en temps\nd’exécution.\nBijective MAC, BMAC\nL’algorithme BMAC87 réalise une empreinte avec une fonction à sens\nunique (SHA2, SHA3…) sur un espace mémoire de taille m, et en utilisant\nune permutation P.\n85 Seshadri, A. et al. \"SCUBA: Secure Code Update By Attestation in sensor\nnetworks.\", in Radha Poovendran & Ari Juels, ed., \"'Workshop on Wireless\nSecurity\" , ACM, , pp. 85-94 (2006).\n86 A. Klimov, and A. Shamir. \"A New Class of Invertible Mappings.\", . CHES,\nvolume 2523 of Lecture Notes in Computer Science, page 470-483. Springer, (2002)\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Bijective MAC, BMAC", "section_path": ["Bijective MAC, BMAC"], "page": 107, "content": "107\nSoit un nombre premier p >m, la permutation P(y) = F(1+y) -1 est basée\nsur des générateurs deux générateurs (g1, g2) et un éléments (s1) dans\nZ/pZ*.\nLorsque l’implémentation de F(x) utilise l’algorithme square & multiply,\non observe une distribution normale pour les temps de calcul.\n87 P. Urien, \"Time Stamped Bijective MAC and Dynamic PUF Authentication\nNew Directions For IoT Security : Invited Paper,\" 2020 Sixth International\nConference on Mobile And Secure Services (MobiSecServ), Miami Beach, FL,\nUSA, 2020\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Differential Power Analysis", "section_path": ["Differential Power Analysis"], "page": 108, "content": "108\nLes Canaux Cachés.\nBien que les algorithmes cryptographiques tels que RSA\nou DES soient considérés comme sûrs d’un point de vue\nmathématiques, il est possible d’extraire les clés à partir des\ntemps d’exécution ou des ondes rayonnées par le\nprocesseur qui réalise ces fonctions. Nous donnons ici deux\nexemples de telles attaques (SPA - Simple Power Analysis &\nDPA – Differential Power Analysis, Paul Kocher).\nSingle Power Analysis\nUn calcul RSA consiste à élever un nombre M (le message en clair) à la\npuissance e en modulo m (le couple e et m constituant la clé privé), soit\nencore\nC(forme chiffrée) = Me modulo m = M x M x ….x M (e fois)\nEn exprimant e sous forme binaire soit,\ne = e0.20 + e1.21 + e2.22 + e3. 23 + e4.24 +...+ ei.2i +...+ ep-1.2p-1, ou ei a pour\nvaleur 0 ou 1.\nLa forme chiffrée s’exprime sous forme d’un produit de p termes mi,\nC = m0. m1 m2…mi… mp-1 modulo m, avec\n- mi= 1, si ei=0,\n- mi= Mi modulo m, si ei=1; M0 = M, Mi = Mi-1 x Mi-1 = M2^i\nEn constate que, dans cette implémentation de l’algorithme RSA (dite\nsquare and multiply), chaque bit (ei) de la clé implique un temps calcul\ndifférent selon que sa valeur soit 0 (multiplication triviale par 1) ou 1\n(multiplication par M2^i). En fonction des différences de temps calcul\nobservées on déduit la valeur de ei (0 ou 1).\nDifferential Power Analysis\nNous avons vu précédemment que dans le cas de RSA, le calcul peut être\nréalisé en p étages, la taille de l’exposant privé étant de p bits.\nSupposons un algorithme cryptographique dont le calcul se décompose\nen p étages. Chaque étage k (k étant compris entre 0 et p-1) prend comme\nargument d’entrée une valeur d'entré Mk,i et calcule la valeur de sortie Mk+1,i.\nM0 , i est un message en clair i, et Mp,i sa forme chiffrée.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Differential Power Analysis", "section_path": ["Differential Power Analysis"], "page": 109, "content": "109\nUn microprocesseur qui exécute un calcul induit des effets physiques\nvariés, par exemple l’énergie consommée ou l’émission d’ondes radio.\nNous désignons par Sk , i(t) un effet physique produit par l’étage de calcul\nk relativement au message i.\nDe surcroît nous imposons que chaque étage k utilise une clé Kk , j dont la\ntaille est de nk bits (j est une valeur comprise entre 0 et 2nk - 1).\nPar exemple dans le cas de l’algorithme DES chaque étage utilise une\n(sous) clé de 6 bits (nk = 6). L’algorithme travaille avec une clé globale de 56\nbits, mais cette dernière est appliquée sur différents blocs de calcul associés à\ndes clés de 6 bits.\nNous supposons l’existence pour chaque étage k d’une fonction gk , j(Mk , i)\nque nous nommons estimateur, telle que pour chaque clé Kk , j ,la moyenne\ndes valeurs d’entrée (Mk,i ) est nulle, c’est à dire que pour toute clé j (j\ncompris entre 0 et 2nk-1):\n1/N x ∑ gk , j(Mk , i) = 0 pour N très grand\n0<i<N-1\nPour fixer les idées nous enregistrons par exemple la puissance\nconsommée Sk , i(t) par le microprocesseur au cours du calcul de l’étage k\npour une valeur d’entrée Mk , i.\nNous calculons pour chaque relevé l’ensemble des 2nk produits Pk , j , i(t)\nPk , j , i (t) = Sk , i(t) gk , j(Mk , i)\nOn obtient 2nk courbes variant dans le temps, pour chaque étage k et pour\nchaque message i.\nSi l’on admet que pour les mauvaises clés les fonctions Sk , i(t) et gk , j(Mk , i)\nne sont pas corrélées au sens statistique du terme, alors la moyenne de leur\nproduit est égal au produit des moyennes, et donc est proche de 0.\n1/N ∑ Pk , j , i (t) = 0(t) pour N très grand et j mauvaise clé\n0<i<N-1\nEn revanche si l’on admet que pour la bonne clé les fonctions Sk , i(t) et\ngk , j(Mk , i) sont corrélées au sens statistique du terme, alors la moyenne de\nleur produit n’est pas égale au produit des moyennes, et donc, n’est pas\nnulle.\n1/N ∑ Pk , j , i # 0(t), pour N très grand et j bonne clé\n0<i<N-1\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 110, "content": "110\nFaites moi confiance ? 20 ans de bugs et heuristiques\nVoici une liste non exhaustive de failles de sécurité.\n- 1995, Peter Shor88 invente un algorithme de factorisation d’un nombre\nN par un calculateur quantique, en un temps O((log N)3). En d’autres termes\nRSA est cassable par une technologie quantique. IBM a factorisé le nombre\n15 (3x5) en utilisant un calculateur quantique de 7 qbits.\n- En juillet 1995, Damien Doligez, doctorant à l’INRIA a cassé un clé RC4\nde 40 bits en une semaine, à l’aide d’une centaine de machines générant\nchacune de l’ordre de 10000 clés/seconde.\n- 1996, Lov K. Grover89 publie un algorithme quantique permettant une\nrecherche exhaustive dans un espace à N éléments en O(√N). En particulier\nune clé de 128 bits peut être cassée selon une complexité de 264. En 2013 la\nsociété Google associée à la NASA a fait l'acquisition d'un ordinateur\nquantique (D-WAVE) de 8x8 qbits (quantum bits).\n- 1998, l’algorithme COMP128-1, qui assure l’authentification des\nabonnés du GSM (algorithme A3/A8) est craqué en 219 (0,5 million) essais\npar l’université de Berkeley90.\n- 1999, Serge Humpich casse la clé RSA privée de 320 bits des cartes\nbancaires, à l’aide d’un logiciel téléchargé sur le WEB.\n- 2001, Fluhrer & All91 cassent le WEP en environ 222 (4 millions) d’essais.\n88 Peter W. Shor, \"Polynomial-Time Algorithms for Prime Factorization and\nDiscrete Logarithms on a Quantum Computer\", 1995.\n89 Lov K. Grover \"A fast quantum mechanical algorithm for database search\",\n1996\n90 Marc Briceno, Ian Goldberg, and David Wagner\n91 S. Fluhrer, I. Mantin, and A. Shamir. “Weaknesses in the key scheduling algorithm of\nRC4”. In Eighth Annual Workshop on Selected Areas in Cryptography, Toronto, Canada,\nAug. 2001.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 111, "content": "111\n- 2002, trois scientifiques indiens92 Manindra Agrawal, Neeraj Kayal et\nNitin Saxena publient le test de primalité AKS, qui a reçu le prix Gödel en\n2006. La complexité de l'algorithme est en O((log n)12) , soit par exemple\npour un nombre de 1024 bits O(2120). D'ou la difficulté dans un protocole\nd'avoir une preuve de la primalité d'un entier. Une variante de AKS de H.\nW. Lenstra, Jr. et Carl Pomerance (2005) réduit la complexité à O((log n)6)\nsoit O(260) pour un nombre de 1024 bits.\n- Mai 2003, Muhammad Faisal Rauf Danka, (étudiant pakistanais) accède\nà tous les comptes Passport.Net, en insérant la chaîne emailpwdreset dans\nune URL d’accès,\nhttps://register.passport.net/emailpwdreset.srf?lc=1033&m=victim@hot\nmail.com&id=&cb=&prefem=attacker@attacker.com&rst=1.\n- Juillet 2003, Jérôme Cretaux met en évidence l’absence de confidentialité\nquant aux informations sensibles, stockées dans les cartes Sésame Vitale.\n- 2004, effondrement de la probabilité de collision de l’algorithme MD5\ndéveloppé dans les années 90, et largement utilisé dans l’internet, dont la\nvaleur théorique était de 1/280 (soit un temps d’attaque \"infini\")\n- Wang et al (2004) 1/239 (temps d’attaque 1 heure)\n- Marc Stevens (2006) 1/232 (temps d’attaque 5 mn)\n- 2005, premier clonage de certificats X509, utilisant des signatures MD5\n(Arjen Lenstra).\n- En 2008, Karsten Nohl, doctorant à Virginia University casse la carte\nMifare Crypto1, vendue à plus de 500 millions d’exemplaires et utilisée par\nexemple comme carte de transport (Oyster card Londres, OV-chipkaart\nPays-Bas, Charlie card Boston). La sécurité de ce composant RFID repose sur\nune clé secrète de 48 bits et un registre à décalage de type Fibonacci LFSR.\n92 Manindra Agrawal, Neeraj Kayal and Nitin Saxena \"PRIMES is in P\", 2002\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 112, "content": "112\n- En 2008, Jeroen van Beek, modifie avec succès le RFID des passeports\nélectroniques Hollandais. L’attaque repose sur deux concepts, réalisation\nd’un clone logiciel et exploitation d’incohérences des spécifications\nd’interopérabilité (une signature incorrecte est une erreur non critique, une\nvaleur de hash erronée est un avertissement).\n- En 2010, un groupe de chercheurs anglais93, mettent en évidence\nl’absence de vérification du code PIN dans certaines cartes bancaires EMV,\nlors de transactions de paiement.\nEn 2010, une présentation au 27ième Chaos Communication Congress à Berlin\n(\"Console Hacking 2010, PS3 Epic Fail\") décrit une attaque permettant\nd'obtenir la clé de signature ECDSA utilisée par les consoles SONY PS3.\nCette dernière est basée sur le fait que le logiciel utilise un nombre aléatoire\nfixe !.... Quelques rappels sur la signature la signature ECDSA:\nn est l'ordre (premier) d'un groupe définit sur une courbe elliptique\nSoit x Є [1,n-1] une clé privé, P= xG ( G un générateur) est la clé publique\nk un nombre aléatoire k Є [1, n-1]\nkG= (x ,y ), et r = x mod n\nR R R\nsize = nombre d'octets de n, size=32 pour une courbe elliptique de 256\nbits.\nH une fonction de hash, e=H(M), M un message. Si H(M) produit plus de\nsize octets, on choisit les size octets les plus à gauche (octets de poids fort).\nLe couple (r,s), avec s = k-1 (e + x r) mod n est la signature du message M.\nSoit deux signatures (r,s1) et (r,s2), e1=h(M1), e2=h(M2) avec le même r.\nLa clé privée s'écrit x = (e1 s2 - e2 s1) r-1 (s1-s2)-1 mod n\n- en 2011 le système RSA SecurID a été victime d’une attaque dite APT\n(pour Advanced Persistent Threat), c'est-à-dire un malware variante du logiciel\nPoison Ivy. Un jeton SecurID possède un numéro de série et stocke une clé\n93 Murdoch, Steven J.; Drimer, Saar; Anderson, Ross; Bond, Mike; \"Chip and\nPIN is Broken\", Security and Privacy (SP), 2010 IEEE Symposium on Digital\nObject Identifier: 10.1109/SP.2010.33\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 113, "content": "113\nsecrète de 128 bits, usuellement nommée seed. Il génère un code basé sur une\nfonction de hash, la date, et le seed, code=h(date||seed). L’utilisateur\nconnait un PIN associé au jeton. Le passcode est la concaténation du code\naffiché par le jeton et du PIN utilisateur. Une base de données stocke les\ntuples seed, numéro de série ainsi que le login utilisateur. Il est possible (?)\nque le seed soit une fonction du numéro de série. L’attaque a (?) permis\nd’obtenir tout ou partie de la base de données. Un avertissement de la\nsociété indique qu’il serait possible de récupérer le seed à partir d’un seul\npasscode.\n- en 2013 Karsten Nohl a présenté lors de la conférence, Black Hat 201394,\nune attaque permettant de «rooter» une carte SIM à partir d’un seul SMS,\nc’est-à-dire d’obtenir une clé DES de 56 bits dont la connaissance permet de\ncharger, d’activer ou de détruire des applications embarquées (dans la SIM).\nCette attaque s’applique à environ 1/8 du parc des cartes SIM. Elle repose\nsur un «bug» logiciel. La réception d’un message contenant un CMAC DES\nd’authentification, dont le contenu est aléatoire, implique la génération d’un\nmessage contenant un CMAC d’authentification calculé avec une clé DES 56\nbits légitime. Le craquage force brute de cette clé utilise la technique dite des\n\"rainbow tables\".\n- Fin 2013, un malware (BlackPOS) logé dans des terminaux de paiement\n(POS) des magasins TARGET réalise le détournement de 40 millions de\ncartes de crédit.\n- En 2013, un document publié par Edward Snowden révèle que les\néchanges de données entre les Data Center de la société Google ne sont pas\nchiffrés.\n94 Karsten Nohl , \"Rooting SIM cards\", Black Hat 2013,\nhttps://media.blackhat.com/us-13/us-13-Nohl-Rooting-SIM-cards-Slides.pdf\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 114, "content": "114\n- en 2014 un groupe95 de chercheurs français publie un algorithme quasi\npolynomial réalisant le calcul d'un logarithme discret dans les corps finis, de\ncomplexité\nPour des corps fini tels que\navec k#q\nou pour des corps de faibles caractéristiques (typiquement 2)\nsoit une complexité de\n- En 2014 Jeff Forristal directeur technique de la société Bluebox a publié\nlors de la conférence96 Blackhat 2014 une attaque Android nommé \"Android\nFake ID\". Le système d'exploitation utilise des chaines de certificats dont la\nracine est un certificat auto-signé pour la vérification des signatures.\nCependant la signature des certificats à l'intérieur de la chaine n'est pas\nvérifiée.\n- En 2014 Apple a publié une faille de sécurité dans le logiciel OPENSSL\nutilisé dans l'iPhone, l'iPad et le Mac OS X; la signature des certificats n'est\npas vérifiée. Le code source responsable du problème est listé ci dessous.\n95 Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé,\n\"A quasi-polynomial algorithm for discrete logarithm in finite fields of small\ncharacteristic\".\n96 https://www.blackhat.com/docs/us-14/materials/us-14-Forristal-Android-\nFakeID-Vulnerability-Walkthrough.pdf\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 115, "content": "115\nstatic OSStatus\nSSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa,\nSSLBuffer signedParams,\nuint8_t *signature, UInt16 signatureLen)\n{\nOSStatus err;\n...\nif ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\ngoto fail;\nif ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)\ngoto fail;\ngoto fail;\nif ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)\ngoto fail;\n...\nfail:\nSSLFreeBuffer(&signedHashes);\nSSLFreeBuffer(&hashCtx);\nreturn err;\n}\n- En 2014 Karsten Nohl (& All) a démontré97 lors de la conférence\nBlackHat 2014 que les mises à jour de firmware des jetons USB ne sont pas\nsécurisées. Selon la norme USB un jeton peut comporter plusieurs fonctions\npar exemple stockage mais également clavier (keys logging) ou interface\nréseau (écoute du trafic)\n97 \"BadUSB On accessories that turn evil\"; KarstenNohl; Sascha Krißler; Jakob\nLell.\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 116, "content": "116\n- En 2015 l'article98 démontre une attaque nommée Logjam qui calcule\nun logarithme discret de p=512 bits dans Z/pZ en une minute, après une\nphase de pré calcul sur le groupe d'environ une semaine. La complexité de\nl'attaque est résumé par la relation ci dessous avec N=2p et k compris entre 1\net 2.\nsoit exp (1 * 7,8 * 9) = 2 1,45*7,8*9 = 2 100\n- En septembre 2016 le malware Mirai se loge dans 145.607 caméras de la\nsociété chinoise XiongMai Technologies,, dans plus de 100 pays, et réalise des\nattaques DDOS. Il génère 1 terabit/s de trafic IP, et produit environ\n35,000/50,000 requêtes HTTP par secondes. Il utilise une faille de sécurité\ntriviale des caméras (une URL permettant d'injecter du code,\nhttp://<IP_address_of_device>/DRV.htm).\n- En 2016 Tobias Boelter99, chercheur à l'université californienne de\nBerkeley, met en évidence un trou de sécurité de l'application WhatsApp100,\nbasé sur une technique MIM (Man In the Middle) possible dans des réseaux\nGSM.\n- En 2017 un groupe de chercheurs101 casse la sécurité des ampoules\nconnectées HUE. Ils démontrent qu’il est possible de les reprogrammer à\npartir d’une voiture ou d’un drone, et donc de propager un malware\ninformatique à l’échelle d’une ville. L’attaque se déroule en deux temps. Une\ncommande unicast de réinitialisation usine, force l’ampoule à rejoindre le\nréseau ZigBee de l’attaquant. Chaque mise à jour du micrologiciel est\nchiffrée et authentifiée par l’algorithme AES-CCM. Cependant, toutes les\nampoules utilisent la même clé, qui a été récupérée par une attaque CPA\n(Correlation Power Analysis).\n98 \"Imperfect Forward Secrecy:How Diffie-Hellman Fails in Practice\" David\nAdrian et Al.\n99 https://tobi.rocks/2016/04/whats-app-retransmission-vulnerability/\n100 WhatsApp Encryption Overview, Technical white paper November 17 2016\n101 Eyal Ronen, Colin O’Flynny, Adi Shamir and Achi-Or Weingarten, \"IoT\nGoes Nuclear: Creating a ZigBee Chain Reaction\", (2017)\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 117, "content": "117\n- En mai 2017 le vers WannaCry (encore dénommé WannaCrypt), a\ninfecté plus de 300 000 ordinateurs, répartis dans plus de 150 pays. Il est\nconsidéré comme le plus grand piratage à rançon (ransonware) de l'histoire\nd'Internet.\nLe malware est basé sur la faille Microsoft \"Windows SMB Server CVE-\n2017-0145 Remote Code Execution Vulnerability\", découverte le 14 mars 2017.\nCette faille est associée au message SMB TREE_CONNECT Response (un\nbuffer overflow ?)\nUn exploit logiciel installe le vers EternalBlue, qui télécharge par la suite\nun ensemble de composants logiciels. Le mécanisme de propagation réalise\nun scan de port TCP 445 (Server Message Block, SMB), puis la détection du\nbug MS17_010, et enfin l'injection de l’exploit Eternal Blue - Double Pulsar.\nUne URL utilisant un nom de domaine à priori non alloué, réalise une sonde\n(Kill Switch) de détection de machine virtuelle.\nLe vers génère une paire de clés RSA (en s'appuyant sur la bibliothèque\nWindows Crypt); des fichiers sont ensuite chiffrés à partir de la clé publique.\nLe ransomware utilise trois adresses Bitcoin pour collecter les paiements:\n 115p7UMMngoj1pMvkpHijcRdfJNXj6LrLn\n 12t9YDPgwueZ9NyMgw519p7AA8isjr6SMw\n 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94\n- En 2019 un groupe de chercheurs102 a démontré une attaque qui\npermet au moyen d’un laser de produire un son sur le microphone MEMS\ndes assistants personnels. Il est possible d’utiliser des commandes vocales\npour ds distances relativement importante (100m).\n- SIM SWAPPING 2020. Le SIM swapping consiste à usurper un numéro\nde mobile. Le pirate demande à activer un numéro sur une carte SIM en sa\npossession. Pour convaincre le service client de l’opérateur, il utilise des\ninformations personnelles (date de naissance, adresse, numéro de client,\n102 Takeshi Sugawara, Benjamin Cyr, USara Rampazzi, Daniel Genkin, Kevin\nFu\n\"Light Commands: Laser-Based Audio Injection Attacks on Voice-Controllable\nSystems”, 2019\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 118, "content": "118\netc.), qu’il a trouvé par ailleurs. Par la suite il peut émettre des appels\ntéléphoniques ou des SMS.\n- Ripple20103. L’entreprise Treck a développé à partir des années 1997\nune librairie TCP/IP; par la suite elle a collaboré avec la société Elmic\nSystems pour de nouvelles versions de cette pile de communication. Cette\ndernière est intégrée dans de nombreux (de l’ordre du milliard) dispositifs\nélectroniques par exemple dans le domaine de la santé. En 2020 le\nlaboratoire JSOF research lab a identifié 19 vulnérabilités104 Zero-Day\npermettant par exemple l’exécution de shell code.\n- SolarWinds 2020. SolarWinds est un éditeur de logiciels (basé au\nTexas), dédiés à la surveillance (monitoring) de réseaux (la plateforme Orion).\nCes produits sont utilisés par des grands groupes tels que: Microsoft ou\nAmazon mais également le Department of Homeland Security (DHS). Un\ncheval de Troie105 a été injecté dans une mise à jour, et détecté en décembre\n2020. C’est une attaque qualifiée de Supply Chain Attack.\n- L’article106 présenté lors de la conférence CHESS 2019, démontre le\nclonage de clés électroniques utilisées par un véhicule TESLA. L’attaque met\nà profit les failles de sécurité de l’algorithme de signature cryptographique\nDST40. La clé secrète (40 bits) est extraite grâce à l’enregistrement de deux\nséquences défi (40bits)/signature (24 bits).\n103 https://www.jsof-tech.com/wp-\ncontent/uploads/2020/06/JSOF_Ripple20_Technical_Whitepaper_June20.pdf\n104 https://i.blackhat.com/USA-20/Wednesday/us-20-Oberman-Hacking-The-\nSupply-Chain-The-Ripple20-Vulnerabilities-Haunt-Tens-Of-Millions-Of-Critical-\nDevices.pdf\n105https://www.microsoft.com/security/blog/2020/12/18/analyzing-solorigate-\nthe-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-\nmicrosoft-defender-helps-protect/\n106 Lennert Wouters, Eduard Marin, Tomer Ashur, Benedikt Gierlichs, Bart\nPreneel, Fast, Furious and Insecure: Passive Keyless Entry and Start Systems in\nModern Supercars, CHESS Conference 2019\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 119, "content": "119\n- L’article107 démontre la récupération d’une clé privé utilisé par les\njetons FIDO U2F, Google Titan Security Key. La procédure\nd’authentification est une signature ECDSA sur la courbe P256. Une attaque\npar canaux caché (DPA) est réalisé avec succès sur l’algorithme \"comb\" qui\nréalise une multiplication scalaire pour un nombre de 256 bits (clé privée) en\n128 opérations.\n- L’article108 démontre une attaque par canaux caché, de type timing\nattack, qui permet de récupérer la clé privée utilisée pour une échange de\nDiffie-Hellman. Elle suppose une clé publique (gb) fixe côté serveur avec une\ntaille de l’ordre de 1024 bits. L’attaquant (le client) génère des clés gaxgri,\nimpliquant la construction de secret partagé gab x gri b. Les versions de TLS\n1.2 et inférieures calculent le pre-master-secret en réalisant une procédure de\nhash sur le secret DH. Cependant les octets nuls de poids fort sont ignorés,\nce qui conduit un calcul sur un nombre binaire de longueur variable.\nCertaines valeurs produisent donc des temps calculs plus petits. L’article\nestime à 20 millions le nombre d’essais nécessaires à l’extraction d’une clé\nprivée de 1024 bits.\n- TLS Raccoon Attack. Le protocole TLS1.3 peut utiliser un secret pré-\npartagé (pre-share-key, PSK) pour authentifier les échanges de Diffie-\nHellman entre client et serveur. L’article109 démontre un nœud internet qui\nréalise la réflexion des paquets TLS vers l’adresse source (celle du client). Si\nle nœud d’origine exécute également un serveur TLS1.3 avec le même PSK,\ncelui-ci reçoit des messages d’un client TLS1.3 PSK supposé distant (l’en tête\nTCP/IP n’est pas liée de manière cryptographique à la charge TLS).\n107 Victor Lomne and Thomas Roche, A Side Journey to Titan Side-Channel\nAttack on the Google Titan Security Key (Revealing and Breaking NXP’s P5x\nECDSA Implementation on the Way), Janvier 2021\n108 Robert Merget, Marcus Brinkmann, Nimrod Aviram, Juraj Somorovsky,\nJohannes Mittmann, and Jörg Schwenk, Raccoon Attack: Finding and Exploiting\nMost-Significant-Bit-Oracles in TLS-DH(E), Février 2021\n109 Nir Drucker and Shay Gueron, Selfie: reflections on TLS 1.3 with PSK, 2019\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Faites moi confiance ? 20 ans de bugs et heuristiques", "section_path": ["Faites moi confiance ? 20 ans de bugs et heuristiques"], "page": 120, "content": "120\n- Attaque EMV 2020. Les références110 111 112 démontrent la réalisation de\ntransactions EMV sans la présentation de code PIN. L’attaque repose sur\ndeux faiblesses cryptographiques du protocol EMV. Le kernel 3 utilisé par le\nstandard Visa qVSDC (aussi dénommé Visa payWave), permet la négociation\nen fonction du montant de la transaction et du type d’application EMV,\nselon deux paramètres TTQ (Terminal Transaction Qualifiers, envoyé à la\ncarte) et CTQ (Card Transaction Qualifiers, généré par la carte). Certaines\napplications EMV hébergées par exemple sur des smartphones Android,\ngèrent la présentation du PIN sur le mobile. L’échange des attributs\nTTQ/CTQ n’est pas protégé par des moyens cryptographiques. Une attaque\nde type relais (Man In the Middle) permet d’indiquer au terminal la (fausse)\nvérification du PIN par le mobile. La deuxième partie de l’attaque consiste à\nmaquiller (à l’aide d’un relais) une application EMV (par exemple\nMastercard) pour la présenter selon le profil Visa qVSDC. Cette opération est\nrendu possible par le fait que la lecture de la liste des applications hébergées\ndans la carte de paiement (stockée dans l’application PSE, Payment System\nEnvironment.) n’est pas protégée\n- Phantom of the ADAS, 2020. L’article113 décrit une attaque sur le\nsystème de conduite autonome des TESLAs (Autopilot – Full Self Driving\nFSD). Des images sont projetées durant une courte période (50 ms), et donc\nsont imperceptibles par un humain. La détection par les caméras\nembarquées de panneaux fantômes, tels que stop, limitation de vitesse, ou\nd’obstacles entrainent des arrêts rapides ou des comportements dangereux.\nUne contremesure est proposée basée sur un réseau à convolution.\n110 David Basin, Ralf Sasse, and Jorge Toro-Pozo, The EMV Standard: Break,\nFix, Verify, 42nd IEEE Symposium on Security and Privacy (S&P), 2021\n111 David Basin, Ralf Sasse, and Jorge Toro-Pozo, Card Brand Mixup\nAttack:Bypassing the PIN in non-Visa cards by Using Them for Visa Transactions,\n30th USENIX Security Symposium, 2021\n112 L.A. Galloway and T. Yunusov, “First contact: New vulnerabilities\nincontactless payments,” in Black Hat Europe 2019\n113 Ben Nassi, Yisroel Mirsky, Dudi Nassi, Raz Ben-Netanel, Oleg Drokin,\nYuval Elovici, Phantom of the ADAS: Securing Advanced Driver-Assistance\nSystems from Split-Second Phantom Attacks, CCS '20: Proceedings of the 2020\nACM SIGSAC Conference on Computer and Communications Security October\n2020\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Spectre et Meltdown: insécurité des processeurs", "section_path": ["Spectre et Meltdown: insécurité des processeurs"], "page": 121, "content": "121\nSpectre et Meltdown: insécurité des processeurs\nAttaque Covert Channel liées aux Micro Architectures\nPubliées en 2017, Spectre114 et Meltdown115 sont deux attaques qui\nexploitent des canaux cachés de cache (Cache side-channel).\nUn cache mémoire stocke le contenu d'adresses dans une page indexée\npar une partie du poids faible de l'adresse (LSB); de multiples pages sont\nassociées à un jeu de poids fort (MSB) différents. Le principe du cache side\nchannel est la mesure de temps de lecture variable selon que la donnée soit\nprésente dans le cache ou pas.\nLa technique dite \"Evict+Reload\" consiste à remplir le cache avant\nl'exécution du programme de la victime à l'aide d'instructions de lecture\nmémoire.\nLa technique dite \"Flush+Reload\", utilise une instruction spécifique pour\nvider le cache, avant l'insertion d'un nouveau contenu.\n114 KOCHER, P., GENKIN, D., GRUSS, D., HAAS, W., HAMBURG, M.,\nLIPP, M., MANGARD, S., PRESCHER, T., SCHWARZ, M., AND YAROM, Y.\n\"Spectre Attacks: Exploiting Speculative Execution\", 2017\n115 LIPP, M., SCHWARZ, M., GRUSS, D., PRESCHER, T., HAAS,W.,\nMANGARD, S., KOCHER, P., GENKIN, D., YAROM, Y.,AND HAMBURG, M.\n\"Meltdown\" 2018\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Spectre et Meltdown: insécurité des processeurs", "section_path": ["Spectre et Meltdown: insécurité des processeurs"], "page": 122, "content": "122\nUn \"covert channel\" (canal caché) désigne tout procédé de communication\npermettant le transfert d'information de manière illicite. un \"cache side\nchannel\" est donc un covert channel basé sur des temps de réponse.\nLes processeurs utilisent généralement une technique d'exécution\nd'instructions dite \"out of order\", selon un algorithme introduit R. M.\nTomasulo116 en 1967. Plusieurs unités exécutent les instructions dont les\nrésultats sont par la suite écrits dans une mémoire cache.\nL'exécution spéculative (Speculative Execution) est une technique utilisée\npar les processeurs performants qui consiste à prédire un chemin\nd'exécution probable. Le résultat d'une instruction de test est évalué, et en\ncas d'échec de cette prédiction, le processeur rétablit le contexte antérieur\ncorrect, ce qui ralentit le temps de traitement. Cependant la mémoire cache\npeut conserver la trace de lecture mémoire.\nSpectre et Meltdown sont deux procédés d'attaque mettant à profit les\ntechniques Out of Order Execution et Speculative Execution.\nSpectre utilise une variable d'attaque x, l'adresse de chargement d'un\nélément du tableau array2, dépend de la valeur array1[x]. Si x est supérieure\nau nombre d'éléments du tableau array1, le contenu de l'adresse mémoire\n@array2 + (256+array1[x]) est transféré dans le cache. L'instruction\nspéculative se comporte comme une sonde permettant d'obtenir de contenu\nde @array1+x\nif (x < array1_size)\ny = array2[array1[x] * 256];\n116 Tomasulo, R. M. An efficient algorithm for exploiting multiple arithmetic\nunits. IBM Journal of research and Development 11, 1 (1967), 25–33.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques récentes sur le Wi-Fi", "section_path": ["Attaques récentes sur le Wi-Fi"], "page": 123, "content": "123\nEscalade de privilège dans Meltdown\nMeltdown met à profit un bug Intel relatif à une escalade de privilège.\nL'exécution spéculative d'une exception permet de basculer du mode user\nvers le mode superviseur. Le mode superviseur accède à toute la mémoire\ndu système, une sonde permet de lire une adresse liée à la valeur d'une\ndonnée par exemple @probe_array + data*4096\nAttaques récentes sur le Wi-Fi\nLa norme 802.11 (1999) définit un protocole de sécurité radio, le WEP .\nSon principe consiste à chiffrer les trames à l’aide de l’algorithme RC4 et\nd’une clé, obtenue par la concaténation d’un secret partagé (de 40 ou 104\nbits) et d’un index transporté en clair dans chaque paquet (un champ de 24\nbits, noté IV).\nRC4 réalise le chiffrement des données en mode flux octets (stream\ncipher), à partir d’une clé de longueur comprise entre 8 et 2048 bits il génère\n(à l’aide d’un Pseudo Random Number Generator PRNG) une suite d’octets\npseudo aléatoire nommée KeyStream. Cette série d’octets (Ksi) est utilisée\npour chiffrer un message en clair (Mi) à l’aide d’un classique protocole de\nVernam, réalisant un ou exclusif (xor) entre Ksi et Mi (Ci = Ksi xor Mi).\nL’intégrité des trames est assurée par le chiffrement du CRC. Cette\nfonction étant linéaire par rapport à l’opération ou exclusif il est possible de\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques récentes sur le Wi-Fi", "section_path": ["Attaques récentes sur le Wi-Fi"], "page": 124, "content": "124\nmodifier un bit dans une trame chiffrée tout en recalculant une valeur\ncorrecte du CRC, c’est la technique d’attaque dite bit flipping.\nL’attaque démontrée par Fluhrer et al. en 2001, permet de recouvrer un\nsecret partagé de 104 bits après l’émission d’approximativement quatre\nmillions de trames chiffrées. Elle utilise des valeurs IV dites résolvantes, de\nla forme (3+B,255,N) avec B un octet du secret partagé et N une valeur\nquelconque comprise entre 0 et 255. Environ 60 valeurs résolvantes suffisent\nà retrouver un octet du secret partagé. Un rapide calcul montre que l’on\nobtient une valeur résolvante toutes les 216 trames, soit 60 occurrences après\nenviron 4 millions de paquets.\nIEEE 802.11 Four Ways Handshake\nUn article publié en 2017117 décrit un scénario d'attaque (\"Attaque par\nréinstallation de clé\") du standard IEEE 802.11i (couramment dénommé\nWPA2) publié en 2004. Malgré une communauté d'utilisateur massive du\nWi-Fi, cette faille de sécurité est donc passée inaperçue pendant 14 ans...\nAprès une procédure d'authentification EAP un secret partagé PMK est\ncalculé par le nœud et le point d'accès. Au terme d'un protocole a quatre\npasses (Four Ways Handshake) les deux parties mettent en place une\nconnexion sécurisée, l'échange des trames est protégée par le protocole\nCCMP utilisant une clé AES TK (Temporal Key) et un aléa (le CCMP IV).\nLes deux premiers paquets du 4 ways handshake comportent deux\nnombres aléatoires (ANonce et SNonce) et un nombre aléatoire r d'anti rejeu.\n117 Mathy Vanhoef, Frank Piessens, \" Key Reinstallation Attacks: Forcing\nNonce Reuse in WPA2\", CCS’17, October 30-November 3, 2017, Dallas, TX, USA\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques récentes sur le Wi-Fi", "section_path": ["Attaques récentes sur le Wi-Fi"], "page": 125, "content": "125\nUne clé PTK (256 bits) est déduite des deux premiers messages selon la\nrelation :\nPTK = PRF(PMK, \"Pairwise key expansion\", Min(AA,SA) ||\nMax(AA,SA) || Min(ANonce, SNonce) || Max(ANonce, SNonce) )\nAA = Authenticator Address\nSA = Station Address\nPRF= Pseudo Random Function\nLa clé de trame (TK) est le poids faible (128 bits) de PTK.\nLes troisième et quatrième paquets du 4 ways handshake comportent le\nnombre r+1 (utilisé comme authentifiant) et notifient l'installation\n(activation) de la clé TK par le point d'accès et le nœud. Par la suite chaque\ntrame MAC chiffrée comporte un Packet Number (PN, 6 octets, initialisé à 1\net incrémenté à chaque paquet).\nLe paramètre IV (13 octets) de l'algorithme CCMP est déduit de PN et de\nl'adresse MAC source). Il comprend 1 octets de priorité, l'adresse MAC (6\noctets) de source, et le paramètre PN (6 octets)\nLe paramètre compteur (16 octets) est de la forme :\nFlag (1octet) || IV || ct (>=0, 2 octets)\nCCMP utilise le mode AES-CTR, dans lequel une succession de\ncompteurs croissants sont chiffrés; l'information en clair est protégée à l'aide\nd'un ou exclusif avec les blocs (16 octets) produits par l'algorithme AES.\nLes messages 3 et 4 peuvent être perdus puisqu'ils sont transportés par\ndes trames MAC. Le rejeu du paquet 3 est donc autorisé, ce qui entraine la\nréinitialisation des paramètres de chiffrements des trames (PN est remis à\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaques sur les fonctions de hash MD5 et SHA-1", "section_path": ["Attaques sur les fonctions de hash MD5 et SHA-1"], "page": 126, "content": "126\nun). En conséquence on observe un rejeu des blocs (Ksi) de chiffrement\nproduits par l'algorithme l'AES-CTR.\nPar exemple si le contenu précédent en clair d'un bloc (Cio = Ksi + Mio)\ndu paquet est connu, on retrouve le contenu en clair (Mi) de la trame chiffrée\n(Ci= Mi + Ksi) après réinstallation grâce à la relation :\nMio + (Ksi + Mio) + (Ksi + Mi) = Mi\nAttaques sur les fonctions de hash MD5 et SHA-1\nUne fonction d’empreinte H produit, à partir d’un message M une valeur\npseudo aléatoire de p bits (soit 2P empreintes). Les attaques sont classées en\ntrois catégories :\n- Collision: Trouver un couple (M, M’), tel que H(M) = H(M’)\n- 1st pré-image, étant donné X, trouver M tel que H(M) = X\n- 2nd pré-image, étant donné M, trouver M’ tel que H(M’) = H(M)\nDans le cas d’un algorithme parfait, la probabilité d’une collision est de\n1/2P/2 (en raison du paradoxe des anniversaires) et pour les pré-images 1/2P.\nEn 2004 des collisions MD5 ont été produites avec un coût de 239, et des\ncollisions SHA1 avec un coût théorique de 269. “A paper by Xiaoyun Wang and\nDengguo Feng and Xuejia Lai and Hongbo Yu has been posted on Aug 17, 2004\nabout Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD,\nshowing collisions for the MD5 hash with the right input vectors”.\nEn 2005 Lenstra et al ont forgé à partir d’un premier certificat X509\n(signature MD5) un second certificat qui conserve la signature du premier\nmais comporte une autre clé RSA publique.\nEn 2008, Stevens et al («Chosen-prefix Collisions for MD5\nand Colliding X.509 Certificates for Different Identities») ont\nintroduit une méthode de collision MD5 avec préfixe choisi,\nqui réalise une collision en environ 250 essais. Cet algorithme\nappliqué sur une plateforme comportant 200 plays station,\npermet de cloner un certificat MD5 en un à deux jours.\nEn 2009, lors de la conférence Eurocrypt’2009, Cameron McDonald,\nPhilip Hawkes et Josef Pieprzyk, ont annoncé un algorithme de collision de\nSHA1 d’une complexité de 252.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Le TOP9 des menaces visant le cloud computing en 2013", "section_path": ["Le TOP9 des menaces visant le cloud computing en 2013"], "page": 127, "content": "127\nEn 2015118 les premières collisions SHA1 (plus précisément sur la\nfonction de compression Compr(IV1,M1)= Compr(IV2,M2) )sont publiées\npar Marc Stevens, Pierre Karpman, et Thomas Peyrin. L'algorithme a une\ncomplexité de 258 et nécessite 10 jours de calcul pour un cluster de 64\nprocesseurs (General Purpose Unit - GPU).\nQuelques TOP10 d'attaques\nLe TOP9 des menaces visant le cloud computing en 2013\nLa virtualisation est une technique inventée par IBM dans les années 70,\npuis déployée par exemple par Microsoft pour Windows95. Cette\ntechnologie est basée sur des hyperviseurs capables de gérer plusieurs\nmachines virtuelles. On distingue les hyperviseurs hébergés (\"hosted\")\nexécutés par un système d’exploitation, ou natifs dans le cas contraire.\nLe rapport119 \"The Notorious Nine Cloud Computing Top Threats in 2013\"\npublié en 2013 par le Cloud Security Alliance établit une liste des 9 attaques\nles plus significatives du Cloud.\n118 \"Freestart collision for full SHA-1\" Marc Stevens, Pierre Karpman, and\nThomas Peyrin, 2015\n119\nhttps://downloads.cloudsecurityalliance.org/initiatives/top_threats/The_Notorious_N\nine_Cloud_Computing_Top_Threats_in_2013.pdf\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Le TOP9 des menaces visant le cloud computing en 2013", "section_path": ["Le TOP9 des menaces visant le cloud computing en 2013"], "page": 128, "content": "128\n1) La fuite de données. Une équipe de chercheurs américains a démontré\nune attaque DPA (Differential Power Analysis) entre des machines virtuelles\npermettant de récupérer des clés cryptographiques privées (\"Cross-VM Side\nChannels and Their Use to ExtractPrivate Keys\", Yinqian Zhang, Ari Juels,\nThomas Ristenpart, Michael K. Reiter, 2012). Le rapport souligne également\nla possibilité d’extraction d’informations à partir d’un trou de sécurité dans\nune application cliente de base de données multi parties (multi-tenant).\n2) La perte de données. La perte de données peut résulter de problèmes\nmatériels du fournisseur de Cloud, de malveillance (vol de mot de passe,\nintrusion…) ou de sinistres divers (incendie, inondation, tempêtes,…).\n3) Détournement de comptes. En avril 2010, une faille de type Cross-Site\nScripting (XSS) a permis à des hackers de récupérer des identifiants de\ncompte Amazon. En 2009, le botnet Zeus s’est propagé sur de nombreux\nsystèmes Amazon.\n4) Interfaces et APIs non sécurisés. L’accès aux ressources du cloud\nimplique un contrôle d’accès et des politiques de sécurité basés sur des\nidentifiants. La collecte de ces identifiants via des interfaces ou APIs\nprésentant des failles de sécurité permet le détournement de comptes\nutilisateurs ou l’abus de privilèges.\n5) Le dénis de service. Les attaques DDOS (distributed denial of service)\ntypiquement menées à l’aide de botnets peuvent être internes ou externes au\ncloud. Une attaque DDoS impacte l’ensemble de clients dont les services\nsont hébergés par un cloud.\n6) Délit d’initié. C’est typiquement un employé ou un ancien employé du\nfournisseur de Cloud qui accède à des fins malveillantes, aux ressources\nhébergées.\n7) Abus de services. Les services du cloud peuvent être utilisés à des fins\nmalhonnêtes, par exemple pour casser des clés cryptographiques ou\nhéberger des sites illégaux (P2P,…)\n8) Manque de compétences. Certaines entreprises n’appréhendent pas\nsuffisamment les compétences requises, notamment en termes de sécurité,\npour réaliser une migration de leurs ressources informatiques dans le cloud.\n9) Vulnérabilités technologiques. Les hyperviseurs peuvent s’appuyer sur\ndes processeurs présentant des failles de sécurité telles que, escalade de\nprivilèges, ou défaut d’isolation mémoire (Memory Management Unit –\nMMU).\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "OWASP TOP10 2013", "section_path": ["OWASP TOP10 2013"], "page": 129, "content": "129\nOWASP TOP10 2013\nOpen Web Application Security Project (OWASP, www.owasp.org) est\nune communauté publique permettant à des organismes de développer,\nacheter et maintenir des applications fiables. Il publie120 chaque année un\nrapport sur dix les risques de sécurité WEB les plus critiques:\nA1- Faille d'injection. Par exemple injection SQL, OS et LDAP. Elle se\nproduit lorsqu'une donnée non fiable est envoyée à un interpréteur, en tant\nqu'élément d'une commande ou d'une requête.\nA2 – Violation de Gestion d'Authentification et de Session. Les fonctions\napplicatives relatives à l'authentification et la gestion de session ne sont\nsouvent pas mises en œuvre correctement. Elles permettent aux attaquants\nde compromettre les mots de passe, clés, jetons de session, ou d'exploiter\nd'autres failles d'implémentation afin de s'approprier les identités d'autres\nutilisateurs.\nA3 – Cross-Site Scripting (XSS). Les failles XSS se produisent lorsqu'une\napplication accepte des données non fiables et les envoie à un browser web\nsans validation appropriée. XSS permet à des attaquants d'exécuter un script\ndans le navigateur de la victime afin de détourner des sessions utilisateur,\nde modifier des sites web, ou rediriger l'utilisateur vers des sites\nmalveillants.\nA4 – Références directes non sécurisées à un objet. Une référence directe\nà un objet se produit quand un développeur expose une référence d'un objet\ninterne, tel que fichier, dossier, enregistrement de base de données, ou clé\nde base de données. Sans un contrôle d'accès ou autre protection, les\nattaquants peuvent manipuler ces références pour accéder à des données\nnon autorisées.\nA5 – Mauvaise configuration Sécurité. Une sécurité pertinente implique\nune configuration sécurisée définie et déployée pour les applications,\ncontextes, serveurs d'application, serveurs web, serveurs de base de données\net la plateformes. Tous ces paramètres doivent être définis, mis en œuvre et\nmaintenus, car beaucoup ne sont pas activés par défaut. Cela implique de\ntenir tous les logiciels à jour.\nA6 – Exposition de données sensibles. Beaucoup d'applications web ne\nprotègent pas correctement les données sensibles telles que les cartes de\n120 http://www.owasp.org/index.php/Top_10\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "OWASP TOP10 2013", "section_path": ["OWASP TOP10 2013"], "page": 130, "content": "130\ncrédit, identifiants d'impôt et informations d'authentification. Les pirates\npeuvent voler ou modifier ces données faiblement protégées, pour réaliser\nun vol d'identité, de la fraude à la carte de crédit ou autres délits. Les\ndonnées sensibles nécessitent une protection supplémentaire, par exemple\nun chiffrement, ainsi que des précautions particulières lors des échanges\navec le navigateur.\nA7 – Manque de contrôle d’accès au niveau fonctionnel. Pratiquement\ntoutes les applications web vérifient les droits d'accès avant de rendre une\nfonction visible dans l'interface utilisateur. Cependant, les applications\ndoivent effectuer les mêmes vérifications de contrôle d'accès sur le serveur\nlors de l'accès à chaque fonction. Si les demandes ne sont pas vérifiées, les\nattaquants seront en mesure de forger des demandes afin d'accéder à une\nfonction non autorisée.\nA8 - Falsification de requête inter-site (CSRF). Une attaque CSRF (Cross\nSite Request Forgery) force le navigateur d'une victime authentifiée à envoyer\nune requête HTTP forgée, comprenant le cookie de session de la victime\nainsi que toute autre information automatiquement inclue, à une application\nweb vulnérable. Ceci permet à l'attaquant de forcer le navigateur de la\nvictime, à générer des requêtes dont l'application vulnérable pense qu'elles\némanent légitimement de la victime.\nA9 - Utilisation de composants avec des vulnérabilités connues. Les\ncomposants vulnérables, tels que bibliothèques, contextes et autres modules\nlogiciels fonctionnent presque toujours avec des privilèges maximum. Ainsi,\nsi exploités, ils peuvent causer des pertes de données sérieuses ou une prise\nde contrôle du serveur. Les applications utilisant ces composants\nvulnérables peuvent compromettre leurs défenses et permettre une série\nd'attaques et d'impacts potentiels.\nA10 – Redirections et renvois non validés. Les applications web\nréorientent et redirigent fréquemment les utilisateurs vers d'autres pages et\nsites internet, et utilisent des données non fiables pour déterminer les pages\nde destination. Sans validation appropriée, les attaquants peuvent réorienter\nles victimes vers des sites de phishing ou de malware, ou utiliser les renvois\npour accéder à des pages non autorisées.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L’attaque BEAST (2011)", "section_path": ["L’attaque BEAST (2011)"], "page": 131, "content": "131\nAttaques TLS diverses\nL’attaque par renégociation (2009)\nEn Novembre 2009, Marsh Ray et Steve Dispensa découvrent (Marsh Ray\net Steeve Dispensa, phonephactor.com, Renegotiating TLS, nov. 2009,\nhttp://www.phonefactor.com/sslgapdocs/Renegotiating_TLS.pdf ) une faille dans\nle protocole SSL/TLS qu’ils nomment Authentication Gap . Cette faiblesse\nprovient du clivage logiciel des protocoles HTTP et TLS. Lors d’une requête\nHTTPS ordinaire (sans certificat client), le serveur déchiffre l’entête HTTP et\ndécouvre que le fichier requis exige un certificat client. Il initialise alors une\ndeuxième session TLS avec mutuelle authentification. L’attaquant se place\nen MIM (Man In the Middle) et détourne la première requête HTTPS sans\ncertificat. Il injecte alors sa propre requête HTTP (codée de telle manière à\nannuler celle qui sera produite ultérieurement par le client légitime. Par la\nsuite il se comporte en un relais passif transportant la deuxième session TLS,\navec le certificat client.\nL’attaque BEAST (2011)\nEn septembre 2011 Juliano Rizzo and Thai Duong ont publié lors de la\nconférence ekoparty à Buenos Aires une attaque dénommée \"Browser Exploit\nAgainst SSL/TLS\" (BEAST). Cette dernière permet de retrouver par\ncomparaison (Oracle) le contenu chiffré d’un entête HTTP, comme par\nexemple un cookie (utilisé par une session Paypal dans leur article).\nL’attaque s’appuie sur une propriété d’un chiffrement en mode CBC (Cipher\nBlock Chaining), lorsque la première valeur (IV ) est connu; elle a été\n0\nanalysée en 2006 par Gregory V. Bard (Gregory V. Bard \"Challenging but\nfeasible Block wise-Adaptive Chosen-Plaintext Attack On SSL\", 2006)\nSoit E un algorithme de chiffrement symétrique (par exemple 3xDES)\nIV connu\n0\nC = E { IV exor M }, IV = C\n0 0 0 1 0\nC = E { IV exor M }, IV = C\n1 1 1 2 1\nC = E { IV exor M }, IV = C\nk k k k+1 k\nLa suite des valeurs Ci représente les éléments chiffrés obtenus à partir\ndes blocs en clair Mi. Dans le cas du 3xDES la taille de ces blocs est de 8\noctets, soit 64 bits d’entropie (264). L’attaquant connait un prochain IV par\nl+1\nobservation des informations préalablement chiffrées. Il injecte la donnée\nIV exor IV exor M* (IV un IV préalablement observé ou connu) dans le but\nl+1 j j\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L’attaque Lucky Thirteen (2013)", "section_path": ["L’attaque Lucky Thirteen (2013)"], "page": 132, "content": "132\nde deviner un bloc précédant en clair M, vérifiant C= E ( IV exor M ) , d’où\nj j j j\nl’on déduit\nC = E ( IV exor IV exor IV exor M* ) = E( IV exor M* ),\nl+1 l+1 l+1 j j\nqui est égal à E(IV exor M) pour M*=M\nj j j\nPratiquement l’attaque exige l’observation des valeurs chiffrées sur le\nréseau (pour collecter les valeurs Ck) et l’injection de données en clair dans\nle navigateur (via un script dans l’attaque de 2011). La force brute implique\ncependant l’injection de 264 blocs dans le cas du 3xDES. L’insertion d’octets\nde bourrage dans l’entête HTTP (de 0 à 7) permet de réduire le nombre\nd’essais.\nPar exemple M* = B7 B6 B5 V7 V6 V5 V4 X, permet de retrouver en 256\nessais la valeur de l’octet X (de rang 3) les octets de préfixe B assurant le\nbourrage et ceux de préfixe V étant connus.\nL’attaque Lucky Thirteen (2013)\nEn 2013 Nadhem J. AlFardan et Kenneth G. Paterson, ont publié une\nattaque nommée Lucky Thirteen (“Lucky Thirteen: Breaking the TLS and\nDTLS Record Protocols” Nadhem J. AlFardan and Kenneth G. Paterson,\n2013).\nCette attaque s’appuie sur un défaut de sécurité des protocoles TLS et\nDTLS: l’intégrité des octets de bourrage (padding) utilisés pour le\nchiffrement en mode bloc, n’est pas garantie par un HMAC.\nSelon les standards TLS et DTLS la structure de padding comprend un\nchamp longueur (un octet L) suivi le de L octets dont la valeur est fixée à L.\nPar exemple 0x00, 0x01 0x01, 0x02 0x02 0x02, et 0xFF suivi de 255 valeurs à\n0xFF.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L’attaque Lucky Thirteen (2013)", "section_path": ["L’attaque Lucky Thirteen (2013)"], "page": 133, "content": "133\nUn message DTLS comporte un champ compteur (SQN, 8 octets) et un\nentête (HDR, 5 octets). L’ensemble SQN || HDR possède donc une\nlongueur de 13 octets.\nL’attaque Lucky Thirteen est du type \"Distinguishing attack\", c’est-à-dire\nque l’attaquant est capable de distinguer le chiffrement de deux messages\nM0 et M1.\nConsidérons deux charges DTLS, Payload0 (P0) et Payload1 (P1)\nP0 = 32 octets + 256 x 0xFF (soit 256 octets de padding)\nP1 = 287 octets + 0x00 (soit un octet de padding)\nSoit 18 blocs de 16 octets (288 octets), chiffrés par l’algorithme AES (en\nmode CBC 128 bits)\nLes messages DTLS M0 et M1 transportant ces charges (P0, P1)\ncomprennent le préfixe SQN || HDR et le suffixe T || Padding. Soit\nM0 = SQN || HDR || P0 || T || pad\nM1 = SQN || HDR || P1 || T || pad\nL’attaquant observe\nM = SQN || HDR || Pi || T || pad\nIl forge\nM’ = SQN || HDR || Pi, ce message est traité par le protocole DTLS\nSi la charge est égale à P0, le message M’ est interprété après\ndéchiffrement comme 12 octets de payload + 20 octets de HMAC-SHA1 et\n256 octets de padding.\nSi la charge est égale à P1, le message M’ est interprété après\ndéchiffrement comme 267 octets de payload + 20 octets HMAC-SHA1 + 1\noctet de padding.\nLes temps de calcul du HMAC sont en conséquence différents.\nL’attaquant souhaite obtenir la valeur en clair (P4) d’un bloc chiffré de 16\noctets (C4), il a également observé la valeur C’ utilisée lors d’un précédent\nchiffrement en mode CBC (dans la séquence C’ || C4)\nC4 = E (P4 exor C’) (E=chiffrement)\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "Attaque TLS Triple Handshake (2014)", "section_path": ["Attaque TLS Triple Handshake (2014)"], "page": 134, "content": "134\nL’attaquant forge une valeur C’ exor X (X une valeur comprise entre 0 et\nFF), puis un message comportant 4 blocs de 16 octets (C1, C2, C’exor X, C4)\nM= SQN || HDR || C1 || C2 || (C’ exor X) || C4 (soit 64+13=77\noctets)\nLe protocole DTLS déchiffre la valeur (D= déchiffrement)\nP4’ = D(C4) exor (C’ exor X) = (P4 exor C’) exor C’ exor X = P4 exor X\nSi le dernier octet de P4’ est 0, le protocole DTLS interprète M comme un\nmessage de de 13 + 43 octets (soit 56 octets) suivi d’un HMAC de 20 octets et\nd’un octet de padding (4x16= 64 = 43 + 20 + 1). Le calcul du HMAC\ns’applique donc à 56 octets\nSi le dernier octet de P4’ indique une longueur de padding dont la\nstructure est correcte (par exemple 0x01 0x01, la suite la plus probable) le\ncalcul du HMAC s’applique à 55 octets au plus. L’algorithme HMAC utilise\ndeux blocs de 64 octets pour une longueur inférieure à 55 et au moins trois\nblocs de 64 octets dans le cas contraire. Cette différence provient de l’ajout\nde 8 octets (indiquant la taille originale) par l’algorithme SHA1 au message à\ntraiter.\nSi la structure du padding est incorrecte, le message est considéré sans\npadding, le calcul du HMAC s’applique à 57-octets (57= 77-20)\nDans tous les cas de calcul HMAC détecte une intégrité erronée, et un\nmessage d’erreur est généré. Le cas d’un padding de longueur supérieur à\nun, implique un temps calcul plus court.\nAttaque TLS Triple Handshake (2014)\nCette attaque121 a été publiée le 4 mars 2014 par une équipe de recherche\nde l’INRIA Rocquencourt. Elles un basée sur un serveur MIM malveillant.\nLe principe de l'attaque est de forger un pre-mastersecret (PMS) identique\npour un serveur MIM malveillant et un serveur licite lors d'une session TLS\nfull. Par la suite le serveur MIM est capable de déchiffrer les messages des\nsessions en mode resume\n121 https://secure-resumption.com/\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "L’attaque RC4 du L’attaque Royal Holloway (2013)", "section_path": ["L’attaque RC4 du L’attaque Royal Holloway (2013)"], "page": 135, "content": "135\nHeartBleed (2014)\nHeartBleed est un bug du logiciel OPENSSL détecter en 1014, qui permet\nde lire un bloc aléatoire de mémoire de 64ko.\nHeartbeat (RFC 6520) est un protocole transporté par la couche\nRecordLayer de TLS, dont il teste le bon fonctionnement grâce à un\nmécanisme d'écho. Il existe deux types de messages, requête et réponse. Le\npremier écrit un bloc de données en mémoire, le deuxième lit le bloc\nprécédemment écrit.\nstruct {\nHeartbeatMessageType type;\nuint16 payload_length;\nopaque payload[HeartbeatMessage.payload_length];\nopaque padding[padding_length];\n} HeartbeatMessage;\nLe bug provient du fait que la taille du bloc d'une requête\n(payload_length) n'est pas vérifiée. La lecture associée (dont la taille de bloc\nest identique) permet d'obtenir une zone mémoire aléatoire (jusqu'a 64 Ko)\nL’attaque RC4 du L’attaque Royal Holloway (2013)\nRC4 est l’algorithme le plus utilisé par le protocole TLS. L’attaque Royal\nHolloway, publiée en juillet 2013 par un groupe de chercheurs (\"On the\nPascal Urien – Télécom Paris – Introduction à la Cyber Sécurité"}
{"pack_id": "french_pack", "language": "fr", "book": "fr_book_2", "section_title": "créa en 1971 le premier microprocesseur 4 bits (le 4004, comportant", "section_path": ["créa en 1971 le premier microprocesseur 4 bits (le 4004, comportant"], "page": 136, "content": "136\nSecurity of RC4 in TLS and WPA\", Nadhem J. AlFardan, Daniel J. Bernstein,\nKenneth G. Paterson, Bertram Poettering, Jacob C. N. Schuldt) repose sur\nl’existence de polarisations (\"biais\") simple octet ou double octet observés\npour l’algorithme RC4.\nUne polarisation simple octet est la probabilité d’obtenir un octet Ksi au\nrang i, avec i >=1. Pour un générateur pseudo aléatoire idéal cette\nprobabilité est de 1/256 (0,390625 %). Cette probabilité a été estimée de\nmanière expérimentale à l’aide d’une distribution 244 keystreams Ksi\nutilisant des clés de 128 bits. Une polarisation significative est observée pour\ntous les octets Ksi pour des rangs inférieurs à 256. Par exemple le 32ième octet\na une probabilité de 0,4% d’avoir pour valeur 224\nL’attaque nécessite le chiffrement d’un message identique par un nombre\n2n de sessions utilisant des clés de 128 bits différentes.\n226 sessions permettent de retrouver les 80 premiers octets avec une\nprobabilité d’au moins 50 %.\n232 sessions permettent de retrouver les 256 premiers octets avec une\nprobabilité d’au moins 96%.\nUne polarisation double octet est la probabilité d’obtenir une valeur\nKsi+1 au rang i+1 connaissant la valeur Ksi au rang i. Dans le cas d’un\ngénérateur pseudo aléatoire idéal, cette probabilité est de 1/256.\nL’attaque nécessite le chiffrement d’un message identique par un nombre\n2n de sessions utilisant des clés de 128 bits différentes. Le premier octet du\nmessage en clair est connu, le but de l’attaquant est d’obtenir la valeur des\n16 octets suivants. Au-delà de 11.230 sessions le message en clair est récupéré\navec une probabilité de 99%.\nPascal Urien – Télécom Paris– Introduction à la Cyber Sécurité"}
